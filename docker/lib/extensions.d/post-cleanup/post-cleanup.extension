#!/bin/bash
# post-cleanup.sh.example - Post-installation cleanup and optimization
# Extension API v1.0
#
# This extension performs cleanup operations after all other extensions are installed.
# It clears caches, removes temporary files, sets permissions, and creates a tools summary.
# Add this to the END of your active-extensions.conf manifest for automatic cleanup.

# Source shared extension library
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$(dirname "$SCRIPT_DIR")/extensions-common.sh"

# ============================================================================
# METADATA
# ============================================================================

EXT_NAME="post-cleanup"
EXT_VERSION="2.0.0"
EXT_DESCRIPTION="Post-installation cleanup and system optimization"
EXT_CATEGORY="utility"
EXT_INSTALL_METHOD="native"  # No installation needed
EXT_UPGRADE_STRATEGY="manual"

# Initialize extension environment
extension_init

# ============================================================================
# PREREQUISITES
# ============================================================================

prerequisites() {
  print_status "Checking prerequisites for ${EXT_NAME}..."

  # No hard prerequisites - cleanup is optional
  # Check for tools used in reporting
  local tools_available=0
  for tool in df free du; do
    command_exists "$tool" && ((tools_available++))
  done

  if [[ $tools_available -gt 0 ]]; then
    print_success "System reporting tools available: $tools_available/3"
  else
    print_warning "No system reporting tools found"
  fi

  print_success "Prerequisites met (cleanup can run)"
  return 0
}

# ============================================================================
# INSTALL
# ============================================================================

install() {
  print_status "Installing ${EXT_NAME}..."
  print_status "This extension has no installation requirements"
  print_success "Nothing to install"
  return 0
}

# ============================================================================
# CONFIGURE
# ============================================================================

configure() {
  print_status "Running post-installation cleanup and optimization..."

  # Detect if running in CI/test mode to skip aggressive operations
  local ci_mode="${CI_MODE:-false}"
  if [[ "$ci_mode" == "true" ]]; then
    print_status "Running in CI mode - using safe cleanup operations only"
  fi

  # Clean package manager caches
  print_status "Cleaning package manager caches..."

  # System package managers
  if command_exists apt-get; then
    print_debug "Cleaning apt cache..."

    # Skip aggressive autoremove in CI mode - it can break ongoing installations
    if [[ "$ci_mode" != "true" ]]; then
      (sudo DEBIAN_FRONTEND=noninteractive apt-get autoremove -y -qq 2>/dev/null) || true
    fi

    # autoclean is safe - just removes old .deb files
    (sudo DEBIAN_FRONTEND=noninteractive apt-get autoclean -qq 2>/dev/null) || true
  fi

  # JavaScript/Node.js
  if command_exists npm; then
    print_debug "Cleaning npm cache..."
    (timeout 30s npm cache clean --force 2>/dev/null) || true
  fi

  if command_exists yarn; then
    print_debug "Cleaning yarn cache..."
    (timeout 30s yarn cache clean 2>/dev/null) || true
  fi

  if command_exists pnpm; then
    print_debug "Cleaning pnpm cache..."
    (timeout 30s pnpm store prune 2>/dev/null) || true
  fi

  # Python
  if command_exists pip3; then
    print_debug "Cleaning pip cache..."
    (timeout 30s pip3 cache purge 2>/dev/null) || true
  fi

  if command_exists poetry; then
    print_debug "Cleaning poetry cache..."
    (timeout 30s poetry cache clear pypi --all -n 2>/dev/null) || true
  fi

  if command_exists pipenv; then
    print_debug "Cleaning pipenv cache..."
    (timeout 30s pipenv --clear 2>/dev/null) || true
  fi

  # Rust
  if command_exists cargo; then
    print_debug "Cleaning cargo cache..."
    if [[ -d ~/.cargo/registry/cache ]]; then
      rm -rf ~/.cargo/registry/cache 2>/dev/null
    fi
    if [[ -d ~/.cargo/git/checkouts ]]; then
      rm -rf ~/.cargo/git/checkouts 2>/dev/null
    fi
    if cargo --list 2>/dev/null | grep -q "cache"; then
      timeout 30s cargo cache --autoclean 2>/dev/null
    fi
  fi

  # Go
  if command_exists go; then
    print_debug "Cleaning go module cache..."
    (timeout 30s go clean -modcache 2>/dev/null) || true
  fi

  # JVM (Maven, Gradle)
  if command_exists mvn; then
    print_debug "Cleaning Maven snapshots..."
    if [[ -d ~/.m2/repository ]]; then
      find ~/.m2/repository -type d -name "*-SNAPSHOT" -exec rm -rf {} + 2>/dev/null
    fi
  fi

  if command_exists gradle; then
    print_debug "Cleaning Gradle cache..."
    if [[ -d ~/.gradle/caches ]]; then
      find ~/.gradle/caches -type d -name "build-cache-*" -exec rm -rf {} + 2>/dev/null
    fi
  fi

  # PHP
  if command_exists composer; then
    print_debug "Cleaning Composer cache..."
    (timeout 30s composer clear-cache 2>/dev/null) || true
  fi

  # Ruby
  if command_exists gem; then
    print_debug "Cleaning Ruby gem cache..."
    (timeout 60s gem cleanup 2>/dev/null) || true
  fi

  if command_exists bundle; then
    print_debug "Cleaning Bundler cache..."
    (timeout 30s bundle clean --force 2>/dev/null) || true
  fi

  # .NET
  if command_exists dotnet; then
    print_debug "Cleaning .NET NuGet cache..."
    # Use timeout and subshell to prevent hanging or shell exit
    (timeout 10s dotnet nuget locals all --clear 2>/dev/null) || true
  fi

  # Docker
  if command_exists docker; then
    # Skip aggressive Docker cleanup in CI mode
    if [[ "$ci_mode" != "true" ]]; then
      print_debug "Cleaning Docker system..."
      (timeout 30s docker system prune -f 2>/dev/null) || true
    fi
  fi

  # Remove temporary files
  if [[ "$ci_mode" != "true" ]]; then
    # Skip /tmp cleanup in CI mode - tests may be using temp files
    print_debug "Removing temporary files..."
    (find /tmp -maxdepth 1 -type f -mtime +1 -delete 2>/dev/null) || true
  fi

  # Clean pip cache (safe in CI)
  if [[ -d ~/.cache/pip ]]; then
    print_debug "Cleaning pip cache..."
    (rm -rf ~/.cache/pip/* 2>/dev/null) || true
  fi

  # Set proper permissions on workspace
  print_debug "Setting workspace permissions..."
  (sudo chown -R developer:developer /workspace 2>/dev/null) || true
  (chmod -R 755 /workspace/scripts 2>/dev/null) || true

  # Create comprehensive tools summary by delegating to each extension
  print_status "Creating comprehensive tools summary..."

  local summary_file="/workspace/.installed-tools.txt"
  local extensions_dir="${SCRIPT_DIR}"
  local active_conf="/workspace/scripts/lib/extensions.d/active-extensions.conf"

  # Fall back to docker/lib/extensions.d if workspace path doesn't exist
  [[ ! -f "$active_conf" ]] && active_conf="${extensions_dir}/active-extensions.conf"

  # Wrap in subshell to prevent any summary generation errors from breaking configure
  (
  {
    echo "# Installed Development Tools"
    echo "# Generated on $(date)"
    echo "# =========================================="
    echo ""
    echo "This summary is generated by querying each installed extension's status."
    echo "Each extension reports the tools it manages."
    echo ""

    # Read active extensions and delegate to their status functions
    if [[ -f "$active_conf" ]]; then
      while IFS= read -r line; do
        # Skip comments and empty lines
        [[ "$line" =~ ^[[:space:]]*# ]] && continue
        [[ -z "${line// }" ]] && continue

        local ext_name
        ext_name=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        local ext_file="${extensions_dir}/${ext_name}.extension"

        if [[ -f "$ext_file" ]]; then
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "Extension: $ext_name"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

          # Call extension's status function with timeout protection
          # Use timeout to prevent any single extension from hanging the entire summary
          if timeout 5s bash -c "source '$ext_file' && status 2>/dev/null"; then
            echo ""
          else
            echo "⚠ Status check timed out or failed for $ext_name"
            echo ""
          fi
        else
          echo "⚠ Extension file not found: $ext_name"
          echo ""
        fi
      done < "$active_conf"
    else
      echo "⚠ No active extensions configuration found"
      echo "Expected location: $active_conf"
    fi

  } > "$summary_file"
  ) || print_warning "Tools summary generation encountered errors (non-fatal)"

  if [[ -f "$summary_file" ]]; then
    print_success "Tools summary saved to $summary_file (delegated to extension status functions)"
  else
    print_warning "Tools summary file was not created"
  fi

  # Run final system optimization
  if [[ "$ci_mode" != "true" ]]; then
    print_status "Running final system optimization..."

    # Update locate database if available (skip in CI - can be slow)
    if command_exists updatedb; then
      (timeout 60s sudo updatedb 2>/dev/null) || true
    fi
  fi

  # Sync filesystem (always safe to do)
  sync 2>/dev/null || true

  print_success "Post-installation cleanup completed"
  return 0
}

# ============================================================================
# VALIDATE
# ============================================================================

validate() {
  print_status "Validating cleanup results..."

  local all_valid=true

  # Check if summary file was created
  if [[ -f "/workspace/.installed-tools.txt" ]]; then
    local tool_count=$(grep -c "^-" "/workspace/.installed-tools.txt" 2>/dev/null || echo 0)
    print_success "Tools summary created: $tool_count tools documented"
  else
    print_warning "Tools summary not found"
    all_valid=false
  fi

  # Check disk space
  if command_exists df; then
    local workspace_usage
    workspace_usage=$(df -h /workspace 2>/dev/null | awk 'NR==2 {print $5}' | sed 's/%//')
    if [[ -n "$workspace_usage" ]] && [[ $workspace_usage -lt 90 ]]; then
      print_success "Workspace disk usage: ${workspace_usage}%"
    else
      print_warning "Workspace disk usage high: ${workspace_usage}%"
    fi
  fi

  if [[ "$all_valid" == "true" ]]; then
    print_success "Validation passed"
  else
    print_warning "Validation completed with warnings"
  fi
  return 0
}

# ============================================================================
# STATUS
# ============================================================================

status() {
  print_extension_header

  # Check installation status (this extension is always "installed" if the script exists)
  # But we check if it has been run (configure step)
  if [[ ! -f "/workspace/.installed-tools.txt" ]]; then
    echo "Status: ✗ NOT CONFIGURED (run configure to execute cleanup)"
    return 1
  fi

  echo "Status: ✓ CONFIGURED"
  echo ""

  # Extension-specific details
  print_status "Tools summary:"
  local tool_count=$(grep -c "^-" "/workspace/.installed-tools.txt" 2>/dev/null || echo 0)
  echo "  Documented tools: $tool_count"
  echo "  Summary location: /workspace/.installed-tools.txt"
  echo ""

  print_status "System resources:"
  # Show system statistics
  if command_exists df; then
    df -h /workspace 2>/dev/null | awk 'NR==2 {print "  Workspace: " $3 " used / " $2 " total (" $5 " full)"}'
    df -h / 2>/dev/null | awk 'NR==2 {print "  System: " $3 " used / " $2 " total (" $5 " full)"}'
  fi

  if command_exists free; then
    free -h | awk 'NR==2 {print "  Memory: " $3 " used / " $2 " total (" $7 " available)"}'
  fi

  return 0
}

# ============================================================================
# UPGRADE
# ============================================================================

upgrade() {
  print_status "Checking ${EXT_NAME}..."

  # Cleanup extension has no tools to upgrade
  print_success "No upgrades needed for cleanup tasks"
  return 0
}

# ============================================================================
# REMOVE
# ============================================================================

remove() {
  print_status "Removing ${EXT_NAME}..."

  # Remove tools summary
  if [[ -f "/workspace/.installed-tools.txt" ]]; then
    if prompt_confirmation "Remove tools summary file?"; then
      rm -f "/workspace/.installed-tools.txt"
      print_success "Tools summary removed"
    else
      print_status "Tools summary preserved"
    fi
  fi

  print_success "Cleanup extension removed"
  print_status "Note: This doesn't undo the cleanup operations"
  return 0
}

# ============================================================================
# MAIN EXECUTION
# ============================================================================

extension_main "$@"
