name: Extension API Compliance Tests

on:
  workflow_call:
    inputs:
      test_app_prefix:
        description: "Test app prefix"
        required: false
        default: "ext-test"
        type: string
      region:
        description: "Fly.io region"
        required: false
        default: "sjc"
        type: string
      skip_cleanup:
        description: "Skip cleanup for debugging"
        required: false
        default: false
        type: boolean
      pre_built_image:
        description: "Pre-built Docker image URL (optional)"
        required: false
        default: ""
        type: string
    secrets:
      FLYIO_AUTH_TOKEN:
        required: true
      ANTHROPIC_API_KEY:
        required: false

permissions:
  contents: read

jobs:
  extension-api-tests:
    name: Test Extension API - ${{ matrix.extension.name }}
    runs-on: ubuntu-latest
    timeout-minutes: 45
    permissions:
      contents: read

    strategy:
      fail-fast: false
      max-parallel: 2
      matrix:
        # Test representative sample of extensions for API compliance
        # Each extension configured with appropriate resources based on installation requirements
        # Resource allocation tuned per OOM analysis (Nov 2025):
        # - Heavy extensions (rust, ruby, jvm, dotnet): 8 GB RAM, more CPUs/performance cores
        # - Medium extensions (golang, python, docker, monitoring): 6 GB RAM
        # - Light extensions (nodejs, php, utilities): 4 GB RAM
        # - SSH timeout varies by installation complexity (90s-180s)
        extension:
          # Heavy language runtimes - large toolchain downloads, parallel component installs
          - name: "rust"
            memory: "8gb"
            cpu_kind: "performance"
            cpu_count: "4"
            ssh_timeout: "180"
          # Medium language runtimes - moderate downloads, multiple components
          - name: "golang"
            memory: "6gb"
            cpu_kind: "shared"
            cpu_count: "2"
            ssh_timeout: "120"
          - name: "python"
            memory: "6gb"
            cpu_kind: "shared"
            cpu_count: "2"
            ssh_timeout: "120"
          # Light language runtimes - fast npm installs
          - name: "nodejs"
            memory: "4gb"
            cpu_kind: "shared"
            cpu_count: "2"
            ssh_timeout: "120"
          # Complex multi-step installs - apt packages + binary downloads
          - name: "docker"
            memory: "6gb"
            cpu_kind: "shared"
            cpu_count: "2"
            ssh_timeout: "120"
          - name: "monitoring"
            memory: "6gb"
            cpu_kind: "shared"
            cpu_count: "2"
            ssh_timeout: "120"
          # Light utilities
          - name: "tmux-workspace"
            memory: "4gb"
            cpu_kind: "shared"
            cpu_count: "2"
            ssh_timeout: "90"
          - name: "openskills"
            memory: "4gb"
            cpu_kind: "shared"
            cpu_count: "2"
            ssh_timeout: "90"
          - name: "agent-manager"
            memory: "4gb"
            cpu_kind: "shared"
            cpu_count: "2"
            ssh_timeout: "90"

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      # NEW: Using composite action for setup
      - name: Setup Fly.io test environment
        id: setup
        uses: ./.github/actions/setup-fly-test-env
        with:
          app-prefix: "${{ inputs.test_app_prefix }}-api"
          extension-name: ${{ matrix.extension.name }}
          fly-api-token: ${{ secrets.FLYIO_AUTH_TOKEN }}
          region: ${{ inputs.region }}
          vm-memory: ${{ matrix.extension.memory }}
          vm-cpu-kind: ${{ matrix.extension.cpu_kind }}
          vm-cpu-count: ${{ matrix.extension.cpu_count }}

      # NEW: Using composite action for deployment
      - name: Deploy test environment
        uses: ./.github/actions/deploy-fly-app
        with:
          app-name: ${{ steps.setup.outputs.app-name }}
          region: ${{ inputs.region }}
          fly-api-token: ${{ secrets.FLYIO_AUTH_TOKEN }}
          deploy-timeout: "600"
          pre-built-image: ${{ inputs.pre_built_image }}
          anthropic-api-key: ${{ secrets.ANTHROPIC_API_KEY }}
          ci-mode: "true"
          vm-memory: ${{ matrix.extension.memory }}
          vm-cpu-kind: ${{ matrix.extension.cpu_kind }}
          vm-cpu-count: ${{ matrix.extension.cpu_count }}

      # NEW: Using composite action for waiting
      - name: Wait for deployment
        uses: ./.github/actions/wait-fly-deployment
        with:
          app-name: ${{ steps.setup.outputs.app-name }}
          fly-api-token: ${{ secrets.FLYIO_AUTH_TOKEN }}
          timeout-seconds: "420"
          expected-status: "started"

      - name: Verify VM resources
        env:
          FLY_API_TOKEN: ${{ secrets.FLYIO_AUTH_TOKEN }}
        run: |
          app_name="${{ steps.setup.outputs.app-name }}"
          expected_memory="${{ matrix.extension.memory }}"
          expected_cpus="${{ matrix.extension.cpu_count }}"
          expected_cpu_kind="${{ matrix.extension.cpu_kind }}"

          echo "üîç Verifying VM resource allocation..."
          echo "Expected: ${expected_memory} MB RAM, ${expected_cpus} CPUs (${expected_cpu_kind})"

          # Get machine status from Fly.io
          echo ""
          echo "=== Fly.io Machine Status ==="
          flyctl status -a "$app_name" --json | jq -r '.Machines[] | {
            id: .id,
            state: .state,
            region: .region,
            instance_id: .instance_id,
            cpus: .config.guest.cpus,
            memory_mb: .config.guest.memory_mb,
            cpu_kind: .config.guest.cpu_kind
          }'

          # Check actual memory inside VM via SSH
          echo ""
          echo "=== Actual VM Memory (from inside VM) ==="
          flyctl ssh console -a "$app_name" --user developer -C "/bin/bash -c '
            echo \"Total RAM (from /proc/meminfo):\"
            grep MemTotal /proc/meminfo

            echo \"\"
            echo \"Available RAM:\"
            grep MemAvailable /proc/meminfo

            echo \"\"
            echo \"Swap:\"
            grep SwapTotal /proc/meminfo

            echo \"\"
            echo \"cgroup memory limit:\"
            cat /sys/fs/cgroup/memory/memory.limit_in_bytes 2>/dev/null || echo \"No cgroup limit\"

            echo \"\"
            echo \"Free memory summary:\"
            free -h
          '"

          # DEFENSIVE: Fail if memory is less than expected
          actual_memory_mb=$(flyctl status -a "$app_name" --json | jq -r '.Machines[0].config.guest.memory_mb // 0')

          # Convert expected_memory to MB for comparison (handles "4096mb", "4gb", or "4096")
          if [[ "$expected_memory" =~ ([0-9]+)gb$ ]]; then
            # Convert GB to MB
            expected_memory_numeric=$((${BASH_REMATCH[1]} * 1024))
          elif [[ "$expected_memory" =~ ([0-9]+)mb$ ]]; then
            # Already in MB
            expected_memory_numeric=${BASH_REMATCH[1]}
          elif [[ "$expected_memory" =~ ^[0-9]+$ ]]; then
            # Assume MB if no unit
            expected_memory_numeric=$expected_memory
          else
            echo "‚ùå ERROR: Invalid memory format: $expected_memory"
            exit 1
          fi

          echo ""
          if [ "$actual_memory_mb" -lt "$expected_memory_numeric" ]; then
            echo "‚ùå ERROR: VM has only ${actual_memory_mb} MB, expected ${expected_memory} (${expected_memory_numeric} MB)"
            echo "This will likely cause OOM failures during installation"
            exit 1
          else
            echo "‚úÖ Memory allocation verified: ${actual_memory_mb} MB (expected: ${expected_memory})"
          fi

      - name: Validate bash environment
        env:
          FLY_API_TOKEN: ${{ secrets.FLYIO_AUTH_TOKEN }}
        run: |
          app_name="${{ steps.setup.outputs.app-name }}"

          echo "üîç Checking for bash function export errors..."

          # Test bash environment for function import errors
          if flyctl ssh console -a "$app_name" --user developer -C "/bin/bash -lc 'echo Environment check passed'" 2>&1 | tee /tmp/bash-check.log | grep -i "syntax error\|error importing function"; then
            echo "‚ùå Bash environment has errors"
            echo ""
            echo "Error details:"
            grep -i "bash:.*error" /tmp/bash-check.log || true
            echo ""
            echo "Exported functions:"
            flyctl ssh console -a "$app_name" --user developer -C "/bin/bash -c 'export -f 2>&1 | head -50'" || true
            exit 1
          else
            echo "‚úÖ Bash environment is clean"
          fi

      - name: Install extension
        env:
          FLY_API_TOKEN: ${{ secrets.FLYIO_AUTH_TOKEN }}
        run: |
          # Source retry utilities
          source .github/scripts/common/ssh-helpers.sh

          app_name="${{ steps.setup.outputs.app-name }}"
          extension="${{ matrix.extension.name }}"
          ssh_timeout="${{ matrix.extension.ssh_timeout }}"

          # Execute install with retry and extension-specific timeout
          ssh_command_retry "$app_name" "$ssh_timeout" "/bin/bash -lc '
            cd /workspace/.system
            manifest=\"manifest/active-extensions.conf\"

            # IDEMPOTENCY: Always start with clean manifest
            # This prevents manifest escalation across retry attempts
            rm -f \$manifest
            touch \$manifest

            # Build manifest with extension and dependencies
            # Note: mise is a core feature, already available
            case \"$extension\" in
              nodejs|python|rust|golang|tmux-workspace|docker|agent-manager)
                # These extensions have no dependencies (mise is core)
                echo \"$extension\" > \$manifest
                ;;
              monitoring)
                # monitoring depends on nodejs and python extensions
                echo \"nodejs\" > \$manifest
                echo \"python\" >> \$manifest
                echo \"$extension\" >> \$manifest
                ;;
              openskills)
                # openskills depends on nodejs extension
                echo \"nodejs\" > \$manifest
                echo \"$extension\" >> \$manifest
                ;;
            esac

            # Verify manifest content before installation
            echo \"üìã Manifest contents:\"
            cat \$manifest
            echo \"\"

            # Install all extensions from manifest
            extension-manager install-all
          '"

      # NEW: Using extracted test-api-compliance.sh script
      - name: Test API compliance (validate, status)
        env:
          FLY_API_TOKEN: ${{ secrets.FLYIO_AUTH_TOKEN }}
        run: |
          # Source retry utilities
          source .github/scripts/common/ssh-helpers.sh

          app_name="${{ steps.setup.outputs.app-name }}"
          extension="${{ matrix.extension.name }}"

          echo "Testing API compliance for $extension..."

          # Create lib directory with retry
          ssh_mkdir_retry "$app_name" /tmp/lib

          # Upload multiple files with retry
          sftp_upload_multiple "$app_name" 666 \
            .github/scripts/extension-tests/test-api-compliance.sh:/tmp/test-api-compliance.sh \
            .github/scripts/extension-tests/lib/test-helpers.sh:/tmp/lib/test-helpers.sh \
            .github/scripts/extension-tests/lib/assertions.sh:/tmp/lib/assertions.sh

          # Execute with retry
          ssh_command_retry "$app_name" "/bin/bash -lc 'bash /tmp/test-api-compliance.sh $extension'"

      - name: Test uninstall() function
        env:
          FLY_API_TOKEN: ${{ secrets.FLYIO_AUTH_TOKEN }}
        run: |
          # Source retry utilities
          source .github/scripts/common/ssh-helpers.sh

          app_name="${{ steps.setup.outputs.app-name }}"
          extension="${{ matrix.extension.name }}"

          echo "Testing uninstall() function for $extension..."

          # Execute with retry
          ssh_command_retry "$app_name" "/bin/bash -lc '
            cd /workspace/.system

            echo \"Running: extension-manager uninstall $extension\"
            if extension-manager uninstall $extension 2>&1 | tee /tmp/uninstall.log; then
              echo \"‚úÖ uninstall() completed\"

              # Verify remove() function was called
              if grep -q \"remove\" /tmp/uninstall.log || grep -q \"Uninstall\" /tmp/uninstall.log; then
                echo \"‚úÖ remove() function executed\"
              else
                echo \"‚ö†Ô∏è  No evidence of remove() execution\"
              fi
            else
              echo \"‚ùå uninstall() failed\"
              exit 1
            fi
          '"

      - name: Test deactivate() function
        env:
          FLY_API_TOKEN: ${{ secrets.FLYIO_AUTH_TOKEN }}
        run: |
          # Source retry utilities
          source .github/scripts/common/ssh-helpers.sh

          app_name="${{ steps.setup.outputs.app-name }}"
          extension="${{ matrix.extension.name }}"

          echo "Testing deactivate() function for $extension..."

          # Execute with retry
          ssh_command_retry "$app_name" "/bin/bash -lc '
            cd /workspace/.system
            manifest=\"manifest/active-extensions.conf\"

            # Re-add extension to manifest (was removed by uninstall)
            echo \"$extension\" >> \$manifest

            echo \"Running: extension-manager deactivate $extension\"
            if extension-manager deactivate $extension 2>&1; then
              echo \"‚úÖ deactivate() completed\"

              # Verify extension removed from manifest
              if grep -q \"^$extension\$\" \$manifest; then
                echo \"‚ùå Extension still in manifest after deactivate\"
                exit 1
              else
                echo \"‚úÖ Extension removed from manifest\"
              fi
            else
              echo \"‚ùå deactivate() failed\"
              exit 1
            fi
          '"

      # NEW: Using composite action for cleanup
      - name: Cleanup test resources
        if: always()
        uses: ./.github/actions/cleanup-fly-app
        with:
          app-name: ${{ steps.setup.outputs.app-name }}
          fly-api-token: ${{ secrets.FLYIO_AUTH_TOKEN }}
