name: Extension System Tests

on:
  push:
    branches: [ main, develop ]
    paths:
      # Deployment configuration
      - 'fly.toml'
      - 'Dockerfile'
      # CI scripts
      - 'scripts/prepare-fly-config.sh'
      - 'scripts/lib/fly-common.sh'
      # Extension system
      - 'docker/lib/extensions.d/**'
      - 'docker/lib/extension-manager.sh'
      - 'docker/lib/common.sh'
      - 'docker/lib/extensions-common.sh'
      # Workflow itself
      - '.github/workflows/extension-tests.yml'
      # Test fixtures
      - '.github/workflows/test-fixtures/**'
  pull_request:
    branches: [ main, develop ]
    paths:
      # Deployment configuration
      - 'fly.toml'
      - 'Dockerfile'
      # CI scripts
      - 'scripts/prepare-fly-config.sh'
      - 'scripts/lib/fly-common.sh'
      # Extension system
      - 'docker/lib/extensions.d/**'
      - 'docker/lib/extension-manager.sh'
      - 'docker/lib/common.sh'
      - 'docker/lib/extensions-common.sh'
      # Workflow itself
      - '.github/workflows/extension-tests.yml'
      # Test fixtures
      - '.github/workflows/test-fixtures/**'
  workflow_dispatch:
    inputs:
      extension_name:
        description: 'Test specific extension (e.g., rust, golang, ai-tools)'
        required: false
        type: string
      skip_cleanup:
        description: 'Skip cleanup for debugging'
        required: false
        default: false
        type: boolean
      skip_idempotency:
        description: 'Skip idempotency tests (faster, but less thorough)'
        required: false
        default: false
        type: boolean

env:
  TEST_APP_PREFIX: "ext-test"
  REGION: "sjc"
  FLY_API_TOKEN: ${{ secrets.FLYIO_AUTH_TOKEN }}

jobs:
  # ============================================================================
  # Job 1: Extension Manager Validation
  # ============================================================================
  extension-manager-validation:
    name: Validate Extension Manager
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Install shellcheck
        run: |
          sudo apt-get update
          sudo apt-get install -y shellcheck

      - name: Validate extension-manager.sh syntax
        run: |
          echo "Running shellcheck on extension-manager.sh..."
          shellcheck docker/lib/extension-manager.sh

      - name: Test extension-manager list command
        run: |
          echo "Testing extension-manager list command..."
          cd docker/lib
          bash extension-manager.sh list

      - name: Test extension name extraction
        run: |
          echo "Testing extension name extraction..."
          cd docker/lib

          # Test with new non-numbered filename format
          test_file="extensions.d/rust.extension"
          if [[ -f "$test_file" ]]; then
            # Extract name using the same logic as extension-manager
            name=$(basename "$test_file" .extension | sed 's/^[0-9]*-//')
            echo "Extracted name from $test_file: $name"

            if [[ "$name" != "rust" ]]; then
              echo "ERROR: Expected 'rust', got '$name'"
              exit 1
            fi
            echo "‚úÖ New naming convention works"
          else
            echo "‚ö†Ô∏è  New format file not found, checking legacy format..."
            # Fallback to test legacy format if it exists
            test_file="extensions.d/10-rust.extension"
            if [[ -f "$test_file" ]]; then
              name=$(basename "$test_file" .extension | sed 's/^[0-9]*-//')
              echo "Extracted name from legacy file: $name"
              if [[ "$name" != "rust" ]]; then
                echo "ERROR: Expected 'rust', got '$name'"
                exit 1
              fi
              echo "‚úÖ Legacy naming convention still supported"
            else
              echo "ERROR: No test files found"
              exit 1
            fi
          fi

          echo "‚úÖ Extension name extraction working correctly"

      - name: Test manifest file operations
        run: |
          echo "Testing manifest file operations..."
          cd docker/lib

          # Create a test manifest
          test_manifest="extensions.d/test-active-extensions.conf"
          cat > "$test_manifest" << 'EOF'
          # Test manifest
          workspace-structure
          nodejs
          # python
          rust
          EOF

          echo "‚úÖ Test manifest created"

          # Test parsing the manifest (count non-comment lines)
          active_count=$(grep -v '^[[:space:]]*#' "$test_manifest" | grep -v '^[[:space:]]*$' | wc -l)
          echo "Active extensions in test manifest: $active_count"

          if [[ "$active_count" -eq 3 ]]; then
            echo "‚úÖ Manifest parsing correct (workspace-structure, nodejs, rust = 3)"
          else
            echo "‚ùå Manifest parsing failed: expected 3, got $active_count"
            exit 1
          fi

          # Cleanup
          rm -f "$test_manifest"
          echo "‚úÖ Manifest file operations working correctly"

      - name: Report validation results
        if: always()
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            echo "‚úÖ Extension manager validation passed"
            echo "## ‚úÖ Extension Manager Validation" >> $GITHUB_STEP_SUMMARY
            echo "All extension manager validation checks passed successfully." >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå Extension manager validation failed"
            echo "## ‚ùå Extension Manager Validation Failed" >> $GITHUB_STEP_SUMMARY
            echo "Extension manager validation encountered errors. Check logs for details." >> $GITHUB_STEP_SUMMARY
          fi

  # ============================================================================
  # Job 2: Extension Syntax Validation
  # ============================================================================
  extension-syntax-validation:
    name: Validate Extension Scripts
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Install shellcheck
        run: |
          sudo apt-get update
          sudo apt-get install -y shellcheck

      - name: Validate all extension scripts
        run: |
          echo "Validating all extension scripts with shellcheck..."

          failed_scripts=()

          for script in docker/lib/extensions.d/*.extension docker/lib/extensions.d/*.sh; do
            # Skip if file doesn't exist (in case no .sh files)
            [[ ! -f "$script" ]] && continue

            echo "Checking $script..."
            if ! shellcheck -x "$script"; then
              failed_scripts+=("$script")
            fi
          done

          if [[ ${#failed_scripts[@]} -gt 0 ]]; then
            echo "‚ùå Shellcheck failed for:"
            printf '%s\n' "${failed_scripts[@]}"
            exit 1
          fi

          echo "‚úÖ All extension scripts pass shellcheck"

      - name: Verify common.sh sourcing
        run: |
          echo "Verifying all extensions source common.sh..."

          missing_source=()

          for script in docker/lib/extensions.d/*.extension; do
            [[ ! -f "$script" ]] && continue

            # Check if script sources common.sh
            if ! grep -q "source.*common\.sh" "$script"; then
              missing_source+=("$script")
            fi
          done

          if [[ ${#missing_source[@]} -gt 0 ]]; then
            echo "‚ö†Ô∏è  Extensions missing common.sh source:"
            printf '%s\n' "${missing_source[@]}"
            echo "This is a warning - extensions may have alternative sourcing"
          else
            echo "‚úÖ All extensions properly source common.sh"
          fi

      - name: Verify shebang presence
        run: |
          echo "Verifying all extensions have proper shebang..."

          missing_shebang=()

          for script in docker/lib/extensions.d/*.extension docker/lib/extensions.d/*.sh; do
            [[ ! -f "$script" ]] && continue

            # Check for shebang on first line
            if ! head -n 1 "$script" | grep -q "^#!/bin/bash"; then
              missing_shebang+=("$script")
            fi
          done

          if [[ ${#missing_shebang[@]} -gt 0 ]]; then
            echo "‚ùå Extensions missing proper shebang:"
            printf '%s\n' "${missing_shebang[@]}"
            exit 1
          fi

          echo "‚úÖ All extensions have proper shebang"

      - name: Check for error handling
        run: |
          echo "Checking for basic error handling patterns..."

          for script in docker/lib/extensions.d/*.extension; do
            [[ ! -f "$script" ]] && continue

            script_name=$(basename "$script")

            # Check if script uses print functions (good practice)
            if grep -q "print_" "$script"; then
              echo "‚úÖ $script_name uses print functions"
            else
              echo "‚ö†Ô∏è  $script_name doesn't use print functions"
            fi
          done

      - name: Verify Extension API v1.0 functions
        run: |
          echo "Verifying Extension API v1.0 standard functions..."

          failed_extensions=()
          required_functions=("prerequisites" "install" "configure" "validate" "status" "remove")

          # Skip template and post-cleanup as they may have different requirements
          skip_patterns="template.extension|post-cleanup.extension"

          for script in docker/lib/extensions.d/*.extension; do
            [[ ! -f "$script" ]] && continue

            script_name=$(basename "$script")

            # Skip special cases
            if echo "$script_name" | grep -qE "$skip_patterns"; then
              echo "‚è≠Ô∏è  Skipping $script_name (special extension)"
              continue
            fi

            echo ""
            echo "Checking $script_name..."

            missing_functions=()
            for func in "${required_functions[@]}"; do
              # Check if function is defined
              if grep -qE "^[[:space:]]*${func}\(\)[[:space:]]*\{" "$script" || \
                 grep -qE "^[[:space:]]*function[[:space:]]+${func}[[:space:]]*\{" "$script"; then
                echo "  ‚úÖ $func() found"
              else
                echo "  ‚ùå $func() missing"
                missing_functions+=("$func")
              fi
            done

            if [[ ${#missing_functions[@]} -gt 0 ]]; then
              echo "  ‚ùå Missing functions in $script_name: ${missing_functions[*]}"
              failed_extensions+=("$script_name")
            else
              echo "  ‚úÖ All Extension API v1.0 functions present"
            fi
          done

          echo ""
          if [[ ${#failed_extensions[@]} -gt 0 ]]; then
            echo "‚ùå Extensions with missing API functions:"
            printf '%s\n' "${failed_extensions[@]}"
            echo ""
            echo "‚ö†Ô∏è  All extensions should implement Extension API v1.0:"
            echo "   - prerequisites()"
            echo "   - install()"
            echo "   - configure()"
            echo "   - validate()"
            echo "   - status()"
            echo "   - remove()"
            exit 1
          else
            echo "‚úÖ All extensions implement Extension API v1.0 correctly"
          fi

      - name: Report validation results
        if: always()
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            echo "‚úÖ Extension syntax validation passed"
            echo "## ‚úÖ Extension Syntax Validation" >> $GITHUB_STEP_SUMMARY
            echo "All extensions pass syntax validation and implement Extension API v1.0." >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå Extension syntax validation failed"
            echo "## ‚ùå Extension Syntax Validation Failed" >> $GITHUB_STEP_SUMMARY
            echo "Some extensions failed syntax validation or are missing required API functions." >> $GITHUB_STEP_SUMMARY
            echo "Check the logs above for specific errors." >> $GITHUB_STEP_SUMMARY
          fi

  # ============================================================================
  # Job 3: Per-Extension Tests (Matrix)
  # ============================================================================
  per-extension-tests:
    name: Test Extension - ${{ matrix.extension.name }}
    runs-on: ubuntu-latest
    timeout-minutes: 60
    permissions:
      contents: read

    strategy:
      fail-fast: false
      max-parallel: 10
      matrix:
        extension:
          # Core extensions (always needed)
          - { name: 'workspace-structure', commands: 'mkdir,ls', key_tool: 'mkdir', timeout: '10m' }
          - { name: 'ssh-environment', commands: 'ssh,sshd', key_tool: 'ssh', timeout: '15m' }
          - { name: 'mise-config', commands: 'mise', key_tool: 'mise', timeout: '10m', uses_mise: 'true' }
          # mise-powered language extensions (faster with mise)
          - { name: 'nodejs', commands: 'node,npm', key_tool: 'node', timeout: '15m', depends_on: 'mise-config', uses_mise: 'true' }
          - { name: 'python', commands: 'python3,pip3', key_tool: 'python3', timeout: '15m', depends_on: 'mise-config', uses_mise: 'true' }
          - { name: 'rust', commands: 'rustc,cargo', key_tool: 'rustc', timeout: '20m', depends_on: 'mise-config', uses_mise: 'true' }
          - { name: 'golang', commands: 'go', key_tool: 'go', timeout: '20m', depends_on: 'mise-config', uses_mise: 'true' }
          - { name: 'nodejs-devtools', commands: 'tsc,eslint,prettier', key_tool: 'tsc', timeout: '15m', depends_on: 'mise-config,nodejs', uses_mise: 'true' }
          # Claude AI extensions
          - { name: 'claude-config', commands: 'claude', key_tool: 'claude', timeout: '15m', depends_on: 'nodejs' }
          # Traditional extensions (unchanged)
          - { name: 'ruby', commands: 'ruby,gem,bundle', key_tool: 'ruby', timeout: '30m' }
          - { name: 'php', commands: 'php,composer', key_tool: 'php', timeout: '30m' }
          - { name: 'jvm', commands: 'java,sdk', key_tool: 'java', timeout: '30m' }
          - { name: 'dotnet', commands: 'dotnet', key_tool: 'dotnet', timeout: '30m' }
          # Infrastructure
          - { name: 'docker', commands: 'docker', key_tool: 'docker', timeout: '30m' }
          - { name: 'infra-tools', commands: 'terraform,ansible', key_tool: 'terraform', timeout: '30m' }
          - { name: 'cloud-tools', commands: 'aws', key_tool: 'aws', timeout: '30m' }
          - { name: 'ai-tools', commands: 'codex,gemini', key_tool: 'codex', timeout: '30m', depends_on: 'nodejs' }
          # Utilities
          - { name: 'playwright', commands: 'playwright', key_tool: 'playwright', timeout: '25m', depends_on: 'nodejs' }
          - { name: 'monitoring', commands: 'claude-monitor,uv', key_tool: 'claude-monitor', timeout: '20m', depends_on: 'python,nodejs' }
          - { name: 'tmux-workspace', commands: 'tmux', key_tool: 'tmux', timeout: '15m' }
          - { name: 'agent-manager', commands: 'agent-manager', key_tool: 'agent-manager', timeout: '15m' }
          - { name: 'context-loader', commands: 'context-load', key_tool: 'echo', timeout: '10m' }
          - { name: 'github-cli', commands: 'gh', key_tool: 'gh', timeout: '15m' }
          - { name: 'post-cleanup', commands: 'echo', key_tool: 'echo', timeout: '10m', run_last: 'true' }

    steps:
      - name: Check if extension should be tested
        id: should-test
        run: |
          # Skip if workflow_dispatch with specific extension that doesn't match
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && \
             [ -n "${{ github.event.inputs.extension_name }}" ] && \
             [ "${{ github.event.inputs.extension_name }}" != "${{ matrix.extension.name }}" ]; then
            echo "should_test=false" >> $GITHUB_OUTPUT
            echo "Skipping ${{ matrix.extension.name }} - not requested"
          else
            echo "should_test=true" >> $GITHUB_OUTPUT
            echo "Testing ${{ matrix.extension.name }}"
          fi

      - name: Checkout code
        if: steps.should-test.outputs.should_test == 'true'
        uses: actions/checkout@v5

      - name: Install Fly CLI
        if: steps.should-test.outputs.should_test == 'true'
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Generate test app name
        if: steps.should-test.outputs.should_test == 'true'
        id: app-name
        run: |
          timestamp=$(date +%s)
          app_name="${TEST_APP_PREFIX}-${{ matrix.extension.name }}-${timestamp}"
          echo "app_name=$app_name" >> $GITHUB_OUTPUT
          echo "Test app name: $app_name"

      - name: Create test SSH key
        if: steps.should-test.outputs.should_test == 'true'
        run: |
          ssh-keygen -t ed25519 -f test_key -N "" -C "ext-test"
          chmod 600 test_key
          chmod 644 test_key.pub

      - name: Prepare fly.toml for testing
        if: steps.should-test.outputs.should_test == 'true'
        env:
          APP_NAME: ${{ steps.app-name.outputs.app_name }}
          VOLUME_NAME: "test_data"
          VOLUME_SIZE: "20"
          VM_MEMORY: "8192"
          CPU_KIND: "performance"
          CPU_COUNT: "4"
          CI_MODE: "true"
        run: |
          ./scripts/prepare-fly-config.sh --ci-mode

      - name: Deploy test environment
        if: steps.should-test.outputs.should_test == 'true'
        run: |
          echo "Deploying test environment for ${{ matrix.extension.name }}..."

          flyctl apps create ${{ steps.app-name.outputs.app_name }} --org personal || echo "App may already exist"

          flyctl volumes create test_data \
            --app ${{ steps.app-name.outputs.app_name }} \
            --region ${REGION} \
            --size 20 \
            --no-encryption \
            --yes

          ssh_key_content=$(cat test_key.pub)
          flyctl secrets set AUTHORIZED_KEYS="$ssh_key_content" \
            --app ${{ steps.app-name.outputs.app_name }}
          flyctl secrets set CI_MODE="true" \
            --app ${{ steps.app-name.outputs.app_name }}

          # Deploy with retry logic
          max_attempts=3
          attempt=1
          while [ $attempt -le $max_attempts ]; do
            echo "Deployment attempt $attempt of $max_attempts..."
            if flyctl deploy --app ${{ steps.app-name.outputs.app_name }} --strategy immediate --wait-timeout 300s --yes; then
              echo "‚úÖ Deployment successful"
              break
            else
              if [ $attempt -lt $max_attempts ]; then
                wait_time=$((30 * attempt))
                echo "‚ö†Ô∏è  Deployment failed, retrying in ${wait_time}s..."
                sleep $wait_time
                attempt=$((attempt + 1))
              else
                echo "‚ùå Deployment failed after $max_attempts attempts"
                exit 1
              fi
            fi
          done

      - name: Wait for deployment
        if: steps.should-test.outputs.should_test == 'true'
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"
          timeout=240
          elapsed=0
          interval=15

          while [ $elapsed -lt $timeout ]; do
            status_output=$(flyctl status --app $app_name 2>&1)

            if echo "$status_output" | grep -q "started"; then
              echo "‚úÖ Deployment successful - machine started"
              echo "Waiting 15s for SSH daemon initialization..."
              sleep 15  # Critical for SSH daemon to fully initialize
              break
            elif echo "$status_output" | grep -q "failed\|crashed\|error"; then
              echo "‚ùå Deployment failed"
              flyctl logs --app $app_name
              exit 1
            fi

            sleep $interval
            elapsed=$((elapsed + interval))
          done

      - name: Verify CI extension manifest
        if: steps.should-test.outputs.should_test == 'true'
        run: |
          echo "Verifying CI extension manifest was created by entrypoint..."

          app_name="${{ steps.app-name.outputs.app_name }}"

          flyctl ssh console --app $app_name --user developer --command '
            cd /workspace/scripts/lib
            manifest_file="extensions.d/active-extensions.conf"

            # Manifest should exist (created by entrypoint.sh in CI mode)
            if [ ! -f "$manifest_file" ]; then
              echo "‚ùå Manifest not found - entrypoint.sh may not have run correctly"
              echo "Creating from CI template as fallback..."
              cp extensions.d/active-extensions.ci.conf "$manifest_file" || {
                echo "‚ùå Failed to create manifest from CI template"
                exit 1
              }
            fi

            echo "‚úÖ Manifest exists: $manifest_file"

            # Verify protected extensions are present
            missing=()
            for ext in workspace-structure mise-config ssh-environment; do
              if ! grep -q "^${ext}$" "$manifest_file"; then
                missing+=("$ext")
              fi
            done

            if [ ${#missing[@]} -gt 0 ]; then
              echo "‚ùå Missing protected extensions: ${missing[*]}"
              echo "Adding missing protected extensions..."
              for ext in "${missing[@]}"; do
                echo "$ext" >> "$manifest_file"
              done
            else
              echo "‚úÖ All protected extensions present"
            fi
            '

      - name: Add extension to manifest
        if: steps.should-test.outputs.should_test == 'true'
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"
          extension_name="${{ matrix.extension.name }}"
          depends_on="${{ matrix.extension.depends_on || '' }}"

          echo "Adding $extension_name to manifest..."
          flyctl ssh console --app $app_name --user developer --command "/bin/bash -lc '
            cd /workspace/scripts/lib
            manifest_file=\"extensions.d/active-extensions.conf\"

            # Create manifest from CI template (already has protected extensions)
            if [ ! -f \"\$manifest_file\" ]; then
              cp extensions.d/active-extensions.ci.conf \"\$manifest_file\" 2>/dev/null || touch \"\$manifest_file\"
            fi

            # Protected extensions already in CI conf - no need to add
            protected=\"workspace-structure mise-config ssh-environment\"

            # Add dependencies first if specified (supports comma-separated list)
            if [ -n \"$depends_on\" ]; then
              echo \"Adding dependencies to manifest: $depends_on\"
              IFS=\",\" read -ra DEPS <<< \"$depends_on\"
              for dep in \"\${DEPS[@]}\"; do
                dep=\$(echo \"\$dep\" | xargs)  # Trim whitespace

                # Skip if protected (already in CI conf)
                if echo \"\$protected\" | grep -q \"\$dep\"; then
                  echo \"‚è≠Ô∏è  Skipping \$dep (protected, already in CI conf)\"
                  continue
                fi

                if ! grep -q \"^\$dep\$\" \"\$manifest_file\" 2>/dev/null; then
                  echo \"\$dep\" >> \"\$manifest_file\"
                  echo \"‚úÖ Dependency \$dep added to manifest\"
                else
                  echo \"‚úÖ Dependency \$dep already in manifest\"
                fi
              done
            fi

            # Add the main extension to manifest (skip if protected)
            if echo \"\$protected\" | grep -q \"$extension_name\"; then
              echo \"‚è≠Ô∏è  Skipping $extension_name (protected, already in CI conf)\"
            elif ! grep -q \"^$extension_name\$\" \"\$manifest_file\" 2>/dev/null; then
              echo \"$extension_name\" >> \"\$manifest_file\"
              echo \"‚úÖ Extension added to manifest\"
            else
              echo \"‚úÖ Extension already in manifest\"
            fi

            # Show active extensions in manifest
            echo \"\"
            echo \"=== Active Extensions in Manifest ===\"
            grep -v \"^[[:space:]]*#\" \"\$manifest_file\" | grep -v \"^[[:space:]]*$\" || echo \"(empty)\"
          '"

      - name: Install extension using install-all
        timeout-minutes: 35
        if: steps.should-test.outputs.should_test == 'true'
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"
          timeout="${{ matrix.extension.timeout }}"

          echo "Running extension-manager install-all for ${{ matrix.extension.name }} extension (timeout: $timeout)..."

          # Enhanced configuration with better error handling and timeout management
          max_config_attempts=2
          config_attempt=1

          while [ $config_attempt -le $max_config_attempts ]; do
            echo "Configuration attempt $config_attempt/$max_config_attempts..."

            if flyctl ssh console --app $app_name --user developer --command "/bin/bash -c '
              export CI_MODE=true
              echo \"=== Starting extension installation ===\"
              echo \"Extension: ${{ matrix.extension.name }}\"
              echo \"Timeout: $timeout\"
              echo \"\"

              # Run with enhanced timeout and logging
              if timeout --kill-after=60s $timeout bash -c \"cd /workspace/scripts/lib && bash extension-manager.sh install-all\" 2>&1 | tee /tmp/configure.log; then
                config_exit_code=\${PIPESTATUS[0]}

                if [ \$config_exit_code -eq 0 ]; then
                  echo \"\"
                  echo \"‚úÖ Configuration completed successfully\"
                  echo \"\"

                  # Verify configuration success markers
                  if grep -q \"Extension setup completed\" /tmp/configure.log || \
                     grep -q \"Configuration complete\" /tmp/configure.log; then
                    echo \"‚úÖ Configuration markers found\"
                  else
                    echo \"‚ö†Ô∏è  No completion markers found, but no errors detected\"
                  fi

                  # Wait for SSH daemon reload to settle
                  echo \"‚è≥ Waiting for SSH environment to stabilize (15 seconds)...\"
                  sleep 15

                  # Verify SSH environment is properly configured
                  if [ -f /etc/profile.d/00-ssh-environment.sh ]; then
                    echo \"‚úÖ SSH environment file present\"
                  else
                    echo \"‚ö†Ô∏è  SSH environment file not found\"
                  fi

                  exit 0
                else
                  echo \"\"
                  echo \"‚ùå Configuration exited with code: \$config_exit_code\"
                  echo \"Last 30 lines of output:\"
                  tail -30 /tmp/configure.log
                  exit 1
                fi
              else
                timeout_exit_code=\$?
                echo \"\"

                if [ \$timeout_exit_code -eq 124 ]; then
                  echo \"‚ùå Configuration timed out after $timeout\"
                elif [ \$timeout_exit_code -eq 137 ]; then
                  echo \"‚ùå Configuration was killed (timeout kill signal)\"
                else
                  echo \"‚ùå Configuration failed with exit code: \$timeout_exit_code\"
                fi

                echo \"\"
                echo \"Last 50 lines of output:\"
                tail -50 /tmp/configure.log

                # Check for specific error patterns
                echo \"\"
                echo \"=== Error Analysis ===\"
                if grep -i \"error\|failed\|timeout\" /tmp/configure.log | tail -10; then
                  echo \"(Errors found in log)\"
                else
                  echo \"No obvious errors in log\"
                fi

                exit 1
              fi
            '"; then
              echo "‚úÖ extension-manager install-all completed successfully"
              break
            else
              exit_code=$?
              config_attempt=$((config_attempt + 1))

              if [ $config_attempt -le $max_config_attempts ]; then
                echo "‚ö†Ô∏è  Configuration attempt failed with exit code $exit_code"
                echo "Checking app status before retry..."
                flyctl status --app $app_name || true
                echo "Waiting 30s before retry..."
                sleep 30
              else
                echo "‚ùå extension-manager install-all failed after $max_config_attempts attempts"
                echo "Retrieving app logs for diagnosis..."
                flyctl logs --app $app_name
                exit 1
              fi
            fi
          done

      - name: Verify commands available
        timeout-minutes: 1
        if: steps.should-test.outputs.should_test == 'true'
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"
          commands="${{ matrix.extension.commands }}"

          echo "Verifying commands are available: $commands"

          # Enhanced verification with retry logic and better error handling
          max_retries=5
          retry_count=0

          while [ $retry_count -lt $max_retries ]; do
            echo "Verification attempt $((retry_count + 1))/$max_retries..."

            if flyctl ssh console --app $app_name --user developer --command "/bin/bash -lc '
              # Source environment to ensure all paths are loaded
              if [ -f /etc/profile.d/00-ssh-environment.sh ]; then
                source /etc/profile.d/00-ssh-environment.sh
              fi

              # Additional environment setup for non-interactive sessions
              if [ -f ~/.bashrc ]; then
                source ~/.bashrc
              fi

              commands=\"$commands\"
              IFS=\",\" read -ra CMD_ARRAY <<< \"\$commands\"
              failed_commands=()

              echo \"=== Command Verification ===\"
              echo \"Current PATH: \$PATH\"
              echo \"\"

              for cmd in \"\${CMD_ARRAY[@]}\"; do
                echo \"Checking command: \$cmd\"

                # Try multiple methods to find the command
                if command -v \"\$cmd\" >/dev/null 2>&1; then
                  echo \"‚úÖ \$cmd available at: \$(command -v \"\$cmd\")\"
                  timeout 5 \"\$cmd\" --version 2>/dev/null || timeout 5 \"\$cmd\" version 2>/dev/null || echo \"  (version check not supported)\"
                elif which \"\$cmd\" >/dev/null 2>&1; then
                  echo \"‚úÖ \$cmd available at: \$(which \"\$cmd\")\"
                  timeout 5 \"\$cmd\" --version 2>/dev/null || timeout 5 \"\$cmd\" version 2>/dev/null || echo \"  (version check not supported)\"
                elif [ -x \"/usr/local/bin/\$cmd\" ]; then
                  echo \"‚úÖ \$cmd available at: /usr/local/bin/\$cmd\"
                  timeout 5 \"/usr/local/bin/\$cmd\" --version 2>/dev/null || echo \"  (version check not supported)\"
                else
                  echo \"‚ùå \$cmd not found in PATH\"
                  echo \"  Searching for \$cmd...\"
                  find /usr/local /opt /home -name \"\$cmd\" -type f 2>/dev/null | head -5 || true
                  failed_commands+=(\"\$cmd\")
                fi
                echo \"\"
              done

              if [ \${#failed_commands[@]} -gt 0 ]; then
                echo \"‚ùå Missing commands: \${failed_commands[*]}\"
                echo \"\"
                echo \"=== Debug Info ===\"
                echo \"Available executables in common locations:\"
                ls -la /usr/local/bin/ 2>/dev/null | head -20 || true
                echo \"\"
                echo \"Environment variables:\"
                env | grep -E \"PATH|HOME|USER\" || true
                exit 1
              fi

              echo \"‚úÖ All commands available and verified\"
              exit 0
            '"; then
              echo "‚úÖ Command verification successful"
              break
            else
              retry_count=$((retry_count + 1))
              if [ $retry_count -lt $max_retries ]; then
                wait_time=$((15 * retry_count))
                echo "‚ö†Ô∏è  Verification failed, retrying in ${wait_time}s..."
                sleep $wait_time
              else
                echo "‚ùå Command verification failed after $max_retries attempts"
                exit 1
              fi
            fi
          done

      - name: Verify mise-managed tools
        timeout-minutes: 2
        if: steps.should-test.outputs.should_test == 'true' && matrix.extension.uses_mise == 'true'
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"
          extension_name="${{ matrix.extension.name }}"

          echo "Verifying mise-managed tools for $extension_name..."

          flyctl ssh console --app $app_name --user developer --command "/bin/bash -lc '
            # Source mise activation
            eval \"\$(mise activate bash)\"

            echo \"=== mise Tool Verification ===\"
            mise ls

            case \"$extension_name\" in
              mise-config)
                echo \"‚úÖ mise-config extension verified\"
                mise --version
                ;;
              nodejs)
                if mise ls node 2>/dev/null | grep -q node; then
                  echo \"‚úÖ Node.js managed by mise\"
                else
                  echo \"‚ùå Node.js not managed by mise\"
                  exit 1
                fi
                ;;
              python)
                if mise ls python 2>/dev/null | grep -q python; then
                  echo \"‚úÖ Python managed by mise\"
                else
                  echo \"‚ùå Python not managed by mise\"
                  exit 1
                fi
                if mise ls pipx 2>/dev/null | grep -q pipx || mise ls | grep -q \"pipx:\"; then
                  echo \"‚úÖ pipx tools managed by mise\"
                else
                  echo \"‚ö†Ô∏è  No pipx tools found (may not be installed yet)\"
                fi
                ;;
              rust)
                if mise ls rust 2>/dev/null | grep -q rust; then
                  echo \"‚úÖ Rust managed by mise\"
                else
                  echo \"‚ùå Rust not managed by mise\"
                  exit 1
                fi
                ;;
              golang)
                if mise ls go 2>/dev/null | grep -q go; then
                  echo \"‚úÖ Go managed by mise\"
                else
                  echo \"‚ùå Go not managed by mise\"
                  exit 1
                fi
                ;;
              nodejs-devtools)
                if mise ls | grep -q \"npm:\"; then
                  echo \"‚úÖ npm tools managed by mise\"
                else
                  echo \"‚ö†Ô∏è  No npm tools found in mise (may not be installed yet)\"
                fi
                ;;
            esac

            echo \"\"
            echo \"‚úÖ mise tool verification completed\"
          '"

      - name: Diagnose environment on failure
        timeout-minutes: 3
        if: failure() && steps.should-test.outputs.should_test == 'true'
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          echo "üîç Environment diagnostics (max 3 minutes)..."
          timeout 150 flyctl ssh console --app $app_name --user developer --command "/bin/bash -lc '
            echo \"===========================================\"
            echo \"   ENVIRONMENT DIAGNOSTICS\"
            echo \"===========================================\"
            echo \"\"

            echo \"=== Basic System Information ===\"
            echo \"Current user: \$(whoami)\"
            echo \"User home: \$HOME\"
            echo \"Current directory: \$(pwd)\"
            echo \"Shell: \$SHELL\"
            echo \"\"

            echo \"=== PATH Configuration ===\"
            echo \"Current PATH:\"
            echo \"\$PATH\" | tr \":\" \"\\n\" | nl
            echo \"\"

            echo \"=== Environment Variables ===\"
            echo \"BASH_ENV: \$BASH_ENV\"
            echo \"CI_MODE: \$CI_MODE\"
            env | grep -E \"PATH|HOME|USER|SHELL|BASH\" | sort
            echo \"\"

            echo \"=== Profile and RC Files ===\"
            for file in /etc/profile ~/.profile ~/.bashrc ~/.bash_profile; do
              if [ -f \"\$file\" ]; then
                echo \"‚úÖ \$file exists\"
              else
                echo \"‚ùå \$file not found\"
              fi
            done
            echo \"\"

            echo \"=== Profile.d Scripts ===\"
            if [ -d /etc/profile.d/ ]; then
              echo \"Profile.d files:\"
              ls -lh /etc/profile.d/ | tail -20
            else
              echo \"‚ùå /etc/profile.d/ directory not found\"
            fi
            echo \"\"

            echo \"=== SSH Environment Configuration ===\"
            if [ -f /etc/profile.d/00-ssh-environment.sh ]; then
              echo \"‚úÖ SSH environment file exists\"
              echo \"Full content:\"
              cat /etc/profile.d/00-ssh-environment.sh
            else
              echo \"‚ùå SSH environment file not found\"
            fi
            echo \"\"

            echo \"=== SSH Daemon Configuration ===\"
            if [ -f /etc/ssh/sshd_config.d/99-bash-env.conf ]; then
              echo \"‚úÖ SSH daemon env config exists\"
              cat /etc/ssh/sshd_config.d/99-bash-env.conf
            else
              echo \"‚ùå SSH daemon env config not found\"
            fi
            echo \"\"

            echo \"=== Extension Manager Status ===\"
            if [ -f /workspace/scripts/lib/extension-manager.sh ]; then
              echo \"‚úÖ Extension manager found\"
              cd /workspace/scripts/lib && bash extension-manager.sh list
            else
              echo \"‚ùå Extension manager not found\"
            fi
            echo \"\"

            echo \"=== Active Extensions ===\"
            if [ -d /workspace/scripts/extensions.d ]; then
              echo \"Activated extensions:\"
              ls -lh /workspace/scripts/extensions.d/*.sh 2>/dev/null || echo \"No active extensions\"
            elif [ -d /workspace/scripts/lib/extensions.d ]; then
              echo \"Activated extensions:\"
              ls -lh /workspace/scripts/lib/extensions.d/*.sh 2>/dev/null || echo \"No active extensions\"
            else
              echo \"‚ùå Extensions directory not found\"
            fi
            echo \"\"

            echo \"=== Installed Tools and Wrappers ===\"
            echo \"Tools in /usr/local/bin:\"
            ls -lh /usr/local/bin/ 2>/dev/null | grep -E \"(go|cargo|rustc|ruby|java|sdk|python|php|docker|terraform|aws|ollama)\" || echo \"No tool wrappers found\"
            echo \"\"

            echo \"=== Extension-Specific Tool Check ===\"
            tool=\"${{ matrix.extension.key_tool }}\"
            echo -n \"Checking \$tool: \"
            if command -v \$tool >/dev/null 2>&1; then
              echo \"Found at \$(command -v \$tool)\"
              timeout 5 \$tool --version 2>/dev/null || timeout 5 \$tool version 2>/dev/null || echo \"  (version check not supported)\"
            else
              echo \"Not found in PATH\"
            fi
            echo \"\"

            echo \"=== Recent Configuration Logs ===\"
            if [ -f /tmp/configure.log ]; then
              echo \"Last 50 lines of configuration log:\"
              tail -50 /tmp/configure.log
            else
              echo \"No configuration log found\"
            fi
            echo \"\"

            echo \"=== System Resources ===\"
            echo \"Disk usage:\"
            df -h / /workspace 2>/dev/null || true
            echo \"\"
            echo \"Memory usage:\"
            free -h 2>/dev/null || true
            echo \"\"

            echo \"===========================================\"
            echo \"   END DIAGNOSTICS\"
            echo \"===========================================\"
          '" || echo "‚ö†Ô∏è  Diagnostics timed out after 150 seconds"

          echo ""
          echo "Retrieving last 100 lines of application logs..."
          timeout 30 flyctl logs --app $app_name || echo "Failed to retrieve logs or timed out"

      - name: Test key functionality
        timeout-minutes: 5
        if: steps.should-test.outputs.should_test == 'true'
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"
          key_tool="${{ matrix.extension.key_tool }}"

          echo "Testing key functionality for $key_tool..."

          flyctl ssh console --app $app_name --user developer --command "/bin/bash -lc '
            # Source SSH environment for non-interactive sessions
            if [ -f /etc/profile.d/00-ssh-environment.sh ]; then
              source /etc/profile.d/00-ssh-environment.sh
            fi

            case \"$key_tool\" in
              mkdir)
                echo \"Testing workspace-structure...\"
                # Verify directory structure created
                for dir in src tests docs scripts bin; do
                  if [ -d \"/workspace/\$dir\" ]; then
                    echo \"‚úÖ /workspace/\$dir exists\"
                  else
                    echo \"‚ö†Ô∏è  /workspace/\$dir not found (may not be created yet)\"
                  fi
                done
                ;;
              ssh)
                echo \"Testing SSH environment configuration...\"
                # Verify SSH daemon env config exists (BASH_ENV setup)
                if [ -f /etc/ssh/sshd_config.d/99-bash-env.conf ]; then
                  echo \"‚úÖ SSH daemon environment config present\"
                  # Verify BASH_ENV is configured
                  if grep -q \"BASH_ENV\" /etc/ssh/sshd_config.d/99-bash-env.conf; then
                    echo \"‚úÖ BASH_ENV configured for non-interactive sessions\"
                  else
                    echo \"‚ö†Ô∏è  BASH_ENV configuration not found\"
                  fi
                else
                  echo \"‚ùå SSH daemon environment config not found\"
                  exit 1
                fi
                # Also check if profile.d environment file exists (optional)
                if [ -f /etc/profile.d/00-ssh-environment.sh ]; then
                  echo \"‚úÖ SSH environment profile.d file present\"
                else
                  echo \"‚ö†Ô∏è  SSH environment profile.d file not present (may be configured differently)\"
                fi
                ;;
              node)
                echo \"Testing Node.js...\"
                node --version
                npm --version
                nvm --version || echo \"‚ö†Ô∏è  nvm not in PATH (may need login shell)\"
                # Test NPM global install location
                npm config get prefix
                ;;
              tsc)
                echo \"Testing TypeScript and dev tools...\"
                npx tsc --version
                npx eslint --version
                npx prettier --version
                npx nodemon --version
                ;;
              claude)
                echo \"Testing Claude Code CLI...\"
                # Check if claude command exists
                if command -v claude >/dev/null 2>&1; then
                  claude --version || echo \"Claude CLI installed\"
                else
                  echo \"‚ö†Ô∏è  Claude CLI not in PATH yet\"
                fi
                ;;
              playwright)
                echo \"Testing Playwright...\"
                npx playwright --version
                ;;
              claude-monitor)
                echo \"Testing monitoring tools...\"
                if command -v claude-monitor >/dev/null 2>&1; then
                  claude-monitor --version || echo \"claude-monitor installed\"
                else
                  echo \"‚ö†Ô∏è  claude-monitor not in PATH yet\"
                fi
                ;;
              tmux)
                echo \"Testing Tmux...\"
                tmux -V
                if [ -f ~/.tmux.conf ] || [ -f /workspace/config/tmux.conf ]; then
                  echo \"‚úÖ Tmux configuration found\"
                else
                  echo \"‚ö†Ô∏è  Tmux config not found\"
                fi
                ;;
              rustc)
                echo \"Testing Rust compilation...\"
                echo \"fn main() { println!(\\\"Hello\\\"); }\" > /tmp/test.rs
                rustc /tmp/test.rs -o /tmp/test && /tmp/test
                ;;
              go)
                echo \"Testing Go compilation...\"
                echo \"package main; import \\\"fmt\\\"; func main() { fmt.Println(\\\"Hello\\\") }\" > /tmp/test.go
                go run /tmp/test.go
                ;;
              python3)
                echo \"Testing Python execution...\"
                python3 -c \"print('Hello')\"
                pip3 --version
                uv --version || echo \"‚ö†Ô∏è  uv not installed\"
                ;;
              java)
                echo \"Testing Java...\"
                java -version
                ;;
              php)
                echo \"Testing PHP...\"
                php -r \"echo 'Hello';\"
                ;;
              ruby)
                echo \"Testing Ruby...\"
                ruby -e \"puts 'Hello'\"
                ;;
              dotnet)
                echo \"Testing .NET...\"
                dotnet --info
                ;;
              docker)
                echo \"Testing Docker...\"
                timeout 10 docker --version
                timeout 10 docker-compose --version 2>/dev/null || timeout 10 docker compose version 2>/dev/null
                ;;
              terraform)
                echo \"Testing Terraform...\"
                terraform version
                ;;
              aws)
                echo \"Testing AWS CLI...\"
                aws --version
                ;;
              ollama)
                echo \"Testing Ollama...\"
                ollama --version
                ;;
              *)
                echo \"‚ö†Ô∏è  No specific test for $key_tool\"
                ;;
            esac

            echo \"‚úÖ Key functionality test passed\"
          '"

      - name: Test enhanced status() output
        timeout-minutes: 2
        if: steps.should-test.outputs.should_test == 'true'
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"
          extension_name="${{ matrix.extension.name }}"

          echo "Testing enhanced status() output for $extension_name..."

          status_output=$(flyctl ssh console --app $app_name --user developer --command "/bin/bash -c '
            cd /workspace/scripts/lib
            bash extension-manager.sh status $extension_name
          '")

          echo "$status_output"

          # Verify status output format
          if echo "$status_output" | grep -q "Extension:"; then
            echo "‚úÖ Status shows extension metadata"
          else
            echo "‚ùå Status missing extension metadata"
            exit 1
          fi

          if echo "$status_output" | grep -q "Status:"; then
            echo "‚úÖ Status shows installation status"
          else
            echo "‚ùå Status missing installation status"
            exit 1
          fi

          echo "‚úÖ Enhanced status() output verified"

      - name: Test idempotency
        timeout-minutes: 10
        if: steps.should-test.outputs.should_test == 'true' && inputs.skip_idempotency != true
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          echo "Testing idempotency (running extension-manager install-all again)..."

          flyctl ssh console --app $app_name --user developer --command "/bin/bash -c '
            echo \"Running configuration a second time...\"
            if bash -c \"cd /workspace/scripts/lib && bash extension-manager.sh install-all\" 2>&1 | tee /tmp/configure2.log; then
              # Check for error indicators in output
              if grep -qi \"error\|failed\" /tmp/configure2.log; then
                echo \"‚ö†Ô∏è  Warnings or errors detected on second run\"
                grep -i \"error\|failed\" /tmp/configure2.log || true
              else
                echo \"‚úÖ Second run completed without errors\"
              fi
            else
              echo \"‚ùå Second run failed\"
              exit 1
            fi
          '"

      - name: Cleanup test resources
        if: always() && !inputs.skip_cleanup
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          machines=$(flyctl machine list --app $app_name --json 2>/dev/null | jq -r '.[].id' || echo "")
          for machine in $machines; do
            [[ -z "$machine" ]] && continue
            flyctl machine stop $machine --app $app_name || true
            sleep 3
            flyctl machine destroy $machine --app $app_name --force || true
          done

          volumes=$(flyctl volumes list --app $app_name --json 2>/dev/null | jq -r '.[].id' || echo "")
          for volume in $volumes; do
            [[ -z "$volume" ]] && continue
            flyctl volumes destroy $volume --app $app_name --yes || true
          done

          flyctl apps destroy $app_name --yes || true
          rm -f test_key test_key.pub

  # ============================================================================
  # Job 4: Extension API Tests (validate, uninstall, deactivate)
  # ============================================================================
  extension-api-tests:
    name: Test Extension API - ${{ matrix.extension }}
    runs-on: ubuntu-latest
    timeout-minutes: 45
    permissions:
      contents: read

    strategy:
      fail-fast: false
      max-parallel: 5
      matrix:
        # Test representative sample of extensions for API compliance
        extension: ['nodejs', 'python', 'rust', 'golang', 'tmux-workspace', 'monitoring']

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Install Fly CLI
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Generate test app name
        id: app-name
        run: |
          timestamp=$(date +%s)
          app_name="${TEST_APP_PREFIX}-api-${{ matrix.extension }}-${timestamp}"
          echo "app_name=$app_name" >> $GITHUB_OUTPUT

      - name: Create test SSH key
        run: |
          ssh-keygen -t ed25519 -f test_key -N "" -C "api-test"
          chmod 600 test_key
          chmod 644 test_key.pub

      - name: Prepare fly.toml
        env:
          APP_NAME: ${{ steps.app-name.outputs.app_name }}
          VOLUME_NAME: "test_data"
          VOLUME_SIZE: "20"
          VM_MEMORY: "4096"
          CPU_KIND: "shared"
          CPU_COUNT: "2"
          CI_MODE: "true"
        run: ./scripts/prepare-fly-config.sh --ci-mode

      - name: Deploy test environment
        run: |
          flyctl apps create ${{ steps.app-name.outputs.app_name }} --org personal || true
          flyctl deploy --app ${{ steps.app-name.outputs.app_name }} \
            --strategy immediate \
            --wait-timeout 600 \
            --ha=false

      - name: Wait for deployment
        timeout-minutes: 8
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"
          max_wait=420
          interval=15
          elapsed=0

          while [ $elapsed -lt $max_wait ]; do
            status_output=$(flyctl status --app $app_name 2>&1 || echo "error")

            if echo "$status_output" | grep -q "running"; then
              echo "‚úÖ Deployment ready"
              break
            elif echo "$status_output" | grep -q "failed\|crashed\|error"; then
              echo "‚ùå Deployment failed"
              exit 1
            fi

            sleep $interval
            elapsed=$((elapsed + interval))
          done

      - name: Install extension
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"
          extension="${{ matrix.extension }}"

          flyctl ssh console --app $app_name --user developer --command "/bin/bash -c '
            cd /workspace/scripts/lib
            manifest=\"extensions.d/active-extensions.conf\"

            # Add dependencies if needed
            case \"$extension\" in
              nodejs|python|rust|golang)
                echo \"mise-config\" > \$manifest
                ;;
              monitoring)
                echo \"mise-config\" > \$manifest
                echo \"nodejs\" >> \$manifest
                echo \"python\" >> \$manifest
                ;;
            esac

            echo \"$extension\" >> \$manifest
            bash extension-manager.sh install-all
          '"

      - name: Test validate() function
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"
          extension="${{ matrix.extension }}"

          echo "Testing validate() function for $extension..."

          flyctl ssh console --app $app_name --user developer --command "/bin/bash -lc '
            cd /workspace/scripts/lib

            echo \"Running: extension-manager validate $extension\"
            if bash extension-manager.sh validate $extension; then
              echo \"‚úÖ validate() returned success\"
            else
              echo \"‚ùå validate() failed for installed extension\"
              exit 1
            fi
          '"

      - name: Test status() function
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"
          extension="${{ matrix.extension }}"

          echo "Testing status() function for $extension..."

          flyctl ssh console --app $app_name --user developer --command "/bin/bash -lc '
            cd /workspace/scripts/lib

            echo \"Running: extension-manager status $extension\"
            output=\$(bash extension-manager.sh status $extension 2>&1)
            echo \"\$output\"

            # Verify output contains expected fields
            if echo \"\$output\" | grep -q \"Extension:\"; then
              echo \"‚úÖ status() shows extension name\"
            else
              echo \"‚ùå status() missing extension name\"
              exit 1
            fi

            if echo \"\$output\" | grep -q \"Status:\"; then
              echo \"‚úÖ status() shows status field\"
            else
              echo \"‚ùå status() missing status field\"
              exit 1
            fi
          '"

      - name: Test uninstall() function
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"
          extension="${{ matrix.extension }}"

          echo "Testing uninstall() function for $extension..."

          flyctl ssh console --app $app_name --user developer --command "/bin/bash -lc '
            cd /workspace/scripts/lib

            echo \"Running: extension-manager uninstall $extension\"
            if bash extension-manager.sh uninstall $extension 2>&1 | tee /tmp/uninstall.log; then
              echo \"‚úÖ uninstall() completed\"

              # Verify remove() function was called
              if grep -q \"remove\" /tmp/uninstall.log || grep -q \"Uninstall\" /tmp/uninstall.log; then
                echo \"‚úÖ remove() function executed\"
              else
                echo \"‚ö†Ô∏è  No evidence of remove() execution\"
              fi
            else
              echo \"‚ùå uninstall() failed\"
              exit 1
            fi
          '"

      - name: Test deactivate() function
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"
          extension="${{ matrix.extension }}"

          echo "Testing deactivate() function for $extension..."

          flyctl ssh console --app $app_name --user developer --command "/bin/bash -lc '
            cd /workspace/scripts/lib
            manifest=\"extensions.d/active-extensions.conf\"

            # Re-add extension to manifest (was removed by uninstall)
            echo \"$extension\" >> \$manifest

            echo \"Running: extension-manager deactivate $extension\"
            if bash extension-manager.sh deactivate $extension 2>&1; then
              echo \"‚úÖ deactivate() completed\"

              # Verify extension removed from manifest
              if grep -q \"^$extension\$\" \$manifest; then
                echo \"‚ùå Extension still in manifest after deactivate\"
                exit 1
              else
                echo \"‚úÖ Extension removed from manifest\"
              fi
            else
              echo \"‚ùå deactivate() failed\"
              exit 1
            fi
          '"

      - name: Cleanup
        if: always()
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          machines=$(flyctl machine list --app $app_name --json 2>/dev/null | jq -r '.[].id' || echo "")
          for machine in $machines; do
            [[ -z "$machine" ]] && continue
            flyctl machine stop $machine --app $app_name || true
            sleep 2
            flyctl machine destroy $machine --app $app_name --force || true
          done

          volumes=$(flyctl volumes list --app $app_name --json 2>/dev/null | jq -r '.[].id' || echo "")
          for volume in $volumes; do
            [[ -z "$volume" ]] && continue
            flyctl volumes destroy $volume --app $app_name --yes || true
          done

          flyctl apps destroy $app_name --yes || true
          rm -f test_key test_key.pub

  # ============================================================================
  # Job 5: Protected Extensions Tests (CRITICAL)
  # ============================================================================
  protected-extensions-tests:
    name: Test Protected Extension Enforcement
    runs-on: ubuntu-latest
    timeout-minutes: 40
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Install Fly CLI
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Generate test app name
        id: app-name
        run: |
          timestamp=$(date +%s)
          app_name="${TEST_APP_PREFIX}-protected-${timestamp}"
          echo "app_name=$app_name" >> $GITHUB_OUTPUT

      - name: Create test SSH key
        run: |
          ssh-keygen -t ed25519 -f test_key -N "" -C "protected-test"
          chmod 600 test_key
          chmod 644 test_key.pub

      - name: Prepare fly.toml
        env:
          APP_NAME: ${{ steps.app-name.outputs.app_name }}
          VOLUME_NAME: "test_data"
          VOLUME_SIZE: "10"
          VM_MEMORY: "2048"
          CPU_KIND: "shared"
          CPU_COUNT: "1"
          CI_MODE: "true"
        run: ./scripts/prepare-fly-config.sh --ci-mode

      - name: Deploy test environment
        run: |
          flyctl apps create ${{ steps.app-name.outputs.app_name }} --org personal || true
          flyctl deploy --app ${{ steps.app-name.outputs.app_name }} \
            --strategy immediate \
            --wait-timeout 600 \
            --ha=false

      - name: Wait for deployment
        timeout-minutes: 8
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"
          max_wait=420
          interval=15
          elapsed=0

          while [ $elapsed -lt $max_wait ]; do
            status_output=$(flyctl status --app $app_name 2>&1 || echo "error")

            if echo "$status_output" | grep -q "running"; then
              echo "‚úÖ Deployment ready"
              break
            elif echo "$status_output" | grep -q "failed\|crashed\|error"; then
              echo "‚ùå Deployment failed"
              exit 1
            fi

            sleep $interval
            elapsed=$((elapsed + interval))
          done

      - name: Install protected extensions
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          flyctl ssh console --app $app_name --user developer --command "/bin/bash -c '
            cd /workspace/scripts/lib
            manifest=\"extensions.d/active-extensions.conf\"

            # Add all protected extensions
            echo \"workspace-structure\" > \$manifest
            echo \"mise-config\" >> \$manifest
            echo \"ssh-environment\" >> \$manifest

            bash extension-manager.sh install-all
          '"

      - name: Test cannot deactivate protected extensions
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          echo "Testing that protected extensions cannot be deactivated..."

          flyctl ssh console --app $app_name --user developer --command "/bin/bash -lc '
            cd /workspace/scripts/lib

            for ext in workspace-structure mise-config ssh-environment; do
              echo \"\"
              echo \"Testing deactivation prevention for \$ext...\"

              # Capture exit code before piping to tee
              bash extension-manager.sh deactivate \$ext 2>&1 | tee /tmp/deactivate_\${ext}.log
              deactivate_exit=\${PIPESTATUS[0]}

              if [ \$deactivate_exit -eq 0 ]; then
                echo \"‚ùå FAIL: \$ext was deactivated (should be protected)\"
                cat /tmp/deactivate_\${ext}.log
                exit 1
              else
                # Check that error message mentions protection
                if grep -qi \"protected\|cannot.*deactivate\" /tmp/deactivate_\${ext}.log; then
                  echo \"‚úÖ PASS: \$ext properly protected from deactivation with correct error message\"
                else
                  echo \"‚ö†Ô∏è  \$ext blocked but no protection message found\"
                  cat /tmp/deactivate_\${ext}.log
                fi
              fi
            done

            echo \"\"
            echo \"‚úÖ All protected extensions properly blocked from deactivation\"
          '"

      - name: Test cannot uninstall protected extensions
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          echo "Testing that protected extensions cannot be uninstalled..."

          flyctl ssh console --app $app_name --user developer --command "/bin/bash -lc '
            cd /workspace/scripts/lib

            for ext in workspace-structure mise-config ssh-environment; do
              echo \"\"
              echo \"Testing uninstall prevention for \$ext...\"

              # Capture exit code before piping to tee
              bash extension-manager.sh uninstall \$ext 2>&1 | tee /tmp/uninstall_\${ext}.log
              uninstall_exit=\${PIPESTATUS[0]}

              if [ \$uninstall_exit -eq 0 ]; then
                echo \"‚ùå FAIL: \$ext was uninstalled (should be protected)\"
                exit 1
              else
                # Check that error message mentions protection
                if grep -qi \"protected\|cannot.*uninstall\" /tmp/uninstall_\${ext}.log; then
                  echo \"‚úÖ PASS: \$ext properly protected from uninstall with correct error message\"
                else
                  echo \"‚ö†Ô∏è  \$ext blocked but no protection message found\"
                  cat /tmp/uninstall_\${ext}.log
                fi
              fi
            done

            echo \"\"
            echo \"‚úÖ All protected extensions properly blocked from uninstall\"
          '"

      - name: Test auto-repair manifest (protected extensions missing)
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          echo "Testing auto-repair when protected extensions removed from manifest..."

          flyctl ssh console --app $app_name --user developer --command "/bin/bash -lc '
            cd /workspace/scripts/lib
            manifest=\"extensions.d/active-extensions.conf\"

            echo \"Removing protected extensions from manifest...\"
            # Backup original
            cp \$manifest \${manifest}.backup

            # Remove protected extensions
            sed -i \"/^workspace-structure$/d\" \$manifest
            sed -i \"/^mise-config$/d\" \$manifest
            sed -i \"/^ssh-environment$/d\" \$manifest

            echo \"\"
            echo \"=== Manifest after removal ===\"
            cat \$manifest || echo \"(empty)\"

            echo \"\"
            echo \"Running: extension-manager list (triggers auto-repair)...\"
            bash extension-manager.sh list

            echo \"\"
            echo \"=== Manifest after auto-repair ===\"
            cat \$manifest

            # Verify protected extensions are back
            echo \"\"
            echo \"Verifying protected extensions were restored...\"
            for ext in workspace-structure mise-config ssh-environment; do
              if grep -q \"^\$ext\$\" \$manifest; then
                echo \"‚úÖ \$ext restored to manifest\"
              else
                echo \"‚ùå \$ext NOT in manifest after auto-repair\"
                exit 1
              fi
            done

            # Verify they are at the top
            echo \"\"
            echo \"Verifying protected extensions are at top of manifest...\"
            head -n 10 \$manifest | grep -E \"^(workspace-structure|mise-config|ssh-environment)$\" || {
              echo \"‚ùå Protected extensions not at top of manifest\"
              exit 1
            }

            echo \"\"
            echo \"‚úÖ Auto-repair correctly restored protected extensions to top of manifest\"
          '"

      - name: Test protected marker in list output
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          echo "Testing that protected extensions show [PROTECTED] marker..."

          flyctl ssh console --app $app_name --user developer --command "/bin/bash -lc '
            cd /workspace/scripts/lib

            echo \"Running: extension-manager list\"
            output=\$(bash extension-manager.sh list 2>&1)
            echo \"\$output\"

            echo \"\"
            echo \"Checking for [PROTECTED] markers...\"
            for ext in workspace-structure mise-config ssh-environment; do
              if echo \"\$output\" | grep \"\$ext\" | grep -q \"PROTECTED\"; then
                echo \"‚úÖ \$ext shows [PROTECTED] marker\"
              else
                echo \"‚ùå \$ext missing [PROTECTED] marker\"
                exit 1
              fi
            done

            echo \"\"
            echo \"‚úÖ All protected extensions show [PROTECTED] marker in list output\"
          '"

      - name: Cleanup
        if: always()
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          machines=$(flyctl machine list --app $app_name --json 2>/dev/null | jq -r '.[].id' || echo "")
          for machine in $machines; do
            [[ -z "$machine" ]] && continue
            flyctl machine stop $machine --app $app_name || true
            sleep 2
            flyctl machine destroy $machine --app $app_name --force || true
          done

          volumes=$(flyctl volumes list --app $app_name --json 2>/dev/null | jq -r '.[].id' || echo "")
          for volume in $volumes; do
            [[ -z "$volume" ]] && continue
            flyctl volumes destroy $volume --app $app_name --yes || true
          done

          flyctl apps destroy $app_name --yes || true
          rm -f test_key test_key.pub

  # ============================================================================
  # Job 6: Cleanup Extensions Tests (CRITICAL)
  # ============================================================================
  cleanup-extensions-tests:
    name: Test Cleanup Extension Ordering
    runs-on: ubuntu-latest
    timeout-minutes: 35
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Install Fly CLI
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Generate test app name
        id: app-name
        run: |
          timestamp=$(date +%s)
          app_name="${TEST_APP_PREFIX}-cleanup-${timestamp}"
          echo "app_name=$app_name" >> $GITHUB_OUTPUT

      - name: Create test SSH key
        run: |
          ssh-keygen -t ed25519 -f test_key -N "" -C "cleanup-test"
          chmod 600 test_key
          chmod 644 test_key.pub

      - name: Prepare fly.toml
        env:
          APP_NAME: ${{ steps.app-name.outputs.app_name }}
          VOLUME_NAME: "test_data"
          VOLUME_SIZE: "10"
          VM_MEMORY: "2048"
          CPU_KIND: "shared"
          CPU_COUNT: "1"
          CI_MODE: "true"
        run: ./scripts/prepare-fly-config.sh --ci-mode

      - name: Deploy test environment
        run: |
          flyctl apps create ${{ steps.app-name.outputs.app_name }} --org personal || true
          flyctl deploy --app ${{ steps.app-name.outputs.app_name }} \
            --strategy immediate \
            --wait-timeout 600 \
            --ha=false

      - name: Wait for deployment
        timeout-minutes: 8
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"
          max_wait=420
          interval=15
          elapsed=0

          while [ $elapsed -lt $max_wait ]; do
            status_output=$(flyctl status --app $app_name 2>&1 || echo "error")

            if echo "$status_output" | grep -q "running"; then
              echo "‚úÖ Deployment ready"
              break
            elif echo "$status_output" | grep -q "failed\|crashed\|error"; then
              echo "‚ùå Deployment failed"
              exit 1
            fi

            sleep $interval
            elapsed=$((elapsed + interval))
          done

      - name: Copy test fixture to VM
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          echo "Copying test fixture to VM..."
          flyctl ssh sftp shell --app $app_name <<'SFTP_CMDS'
            put .github/workflows/test-fixtures/manifest-cleanup-middle.conf /tmp/test-manifest.conf
            bye
          SFTP_CMDS

      - name: Test cleanup extension auto-moves to end
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          echo "Testing that cleanup extensions automatically move to end of manifest..."

          flyctl ssh console --app $app_name --user developer --command "/bin/bash -lc '
            cd /workspace/scripts/lib
            manifest=\"extensions.d/active-extensions.conf\"

            echo \"Copying test fixture to manifest location...\"
            cp /tmp/test-manifest.conf \$manifest

            echo \"\"
            echo \"=== Manifest before auto-reorder ===\"
            cat \$manifest

            echo \"\"
            echo \"Running: extension-manager list (triggers ensure_cleanup_extensions_last)...\"
            bash extension-manager.sh list > /dev/null 2>&1

            echo \"\"
            echo \"=== Manifest after auto-reorder ===\"
            cat \$manifest

            echo \"\"
            echo \"Verifying post-cleanup is at end...\"
            if tail -n 3 \$manifest | grep -q \"^post-cleanup\"; then
              echo \"‚úÖ post-cleanup correctly moved to end of manifest\"
            else
              echo \"‚ùå post-cleanup not at end of manifest\"
              echo \"Last 5 lines:\"
              tail -n 5 \$manifest
              exit 1
            fi

            echo \"\"
            echo \"Verifying protected extensions still at top...\"
            if head -n 5 \$manifest | grep -q \"^workspace-structure\" && \
               head -n 5 \$manifest | grep -q \"^mise-config\" && \
               head -n 5 \$manifest | grep -q \"^ssh-environment\"; then
              echo \"‚úÖ Protected extensions still at top\"
            else
              echo \"‚ùå Protected extensions not at top\"
              exit 1
            fi
          '"

      - name: Cleanup
        if: always()
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          machines=$(flyctl machine list --app $app_name --json 2>/dev/null | jq -r '.[].id' || echo "")
          for machine in $machines; do
            [[ -z "$machine" ]] && continue
            flyctl machine stop $machine --app $app_name || true
            sleep 2
            flyctl machine destroy $machine --app $app_name --force || true
          done

          volumes=$(flyctl volumes list --app $app_name --json 2>/dev/null | jq -r '.[].id' || echo "")
          for volume in $volumes; do
            [[ -z "$volume" ]] && continue
            flyctl volumes destroy $volume --app $app_name --yes || true
          done

          flyctl apps destroy $app_name --yes || true
          rm -f test_key test_key.pub

  # ============================================================================
  # Job 7: Manifest Operations Tests
  # ============================================================================
  manifest-operations-tests:
    name: Test Manifest Operations
    runs-on: ubuntu-latest
    timeout-minutes: 35
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Install Fly CLI
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Generate test app name
        id: app-name
        run: |
          timestamp=$(date +%s)
          app_name="${TEST_APP_PREFIX}-manifest-${timestamp}"
          echo "app_name=$app_name" >> $GITHUB_OUTPUT

      - name: Create test SSH key
        run: |
          ssh-keygen -t ed25519 -f test_key -N "" -C "manifest-test"
          chmod 600 test_key
          chmod 644 test_key.pub

      - name: Prepare fly.toml
        env:
          APP_NAME: ${{ steps.app-name.outputs.app_name }}
          VOLUME_NAME: "test_data"
          VOLUME_SIZE: "10"
          VM_MEMORY: "2048"
          CPU_KIND: "shared"
          CPU_COUNT: "1"
          CI_MODE: "true"
        run: ./scripts/prepare-fly-config.sh --ci-mode

      - name: Deploy test environment
        run: |
          flyctl apps create ${{ steps.app-name.outputs.app_name }} --org personal || true
          flyctl deploy --app ${{ steps.app-name.outputs.app_name }} \
            --strategy immediate \
            --wait-timeout 600 \
            --ha=false

      - name: Wait for deployment
        timeout-minutes: 8
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"
          max_wait=420
          interval=15
          elapsed=0

          while [ $elapsed -lt $max_wait ]; do
            status_output=$(flyctl status --app $app_name 2>&1 || echo "error")

            if echo "$status_output" | grep -q "running"; then
              echo "‚úÖ Deployment ready"
              break
            elif echo "$status_output" | grep -q "failed\|crashed\|error"; then
              echo "‚ùå Deployment failed"
              exit 1
            fi

            sleep $interval
            elapsed=$((elapsed + interval))
          done

      - name: Copy test fixtures to VM
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          echo "Copying test fixtures to VM..."
          flyctl ssh sftp shell --app $app_name <<'SFTP_EOF'
            put .github/workflows/test-fixtures/manifest-reorder-test.conf /tmp/manifest-reorder.conf
            put .github/workflows/test-fixtures/manifest-with-comments.conf /tmp/manifest-comments.conf
            bye
          SFTP_EOF

      - name: Test reorder functionality
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          echo "Testing extension reorder functionality..."

          flyctl ssh console --app $app_name --user developer --command "/bin/bash -lc '
            cd /workspace/scripts/lib
            manifest=\"extensions.d/active-extensions.conf\"

            echo \"Using test fixture for reorder test...\"
            cp /tmp/manifest-reorder.conf \$manifest

            echo \"\"
            echo \"=== Initial manifest ===\"
            cat -n \$manifest

            echo \"\"
            echo \"Running: extension-manager reorder python 5\"
            if bash extension-manager.sh reorder python 5 2>&1; then
              echo \"\"
              echo \"=== Manifest after reorder ===\"
              cat -n \$manifest

              # Check that python is at the 5th non-comment line (extension position 5)
              # With 1 comment line at top, this would be file line 6
              extension_line=\$(grep -v \"^#\" \$manifest | grep -v \"^$\" | sed -n \"5p\")
              if echo \"\$extension_line\" | grep -q \"^python\"; then
                echo \"\"
                echo \"‚úÖ python correctly moved to extension position 5\"
                echo \"Extension at position 5: \$extension_line\"
              else
                echo \"\"
                echo \"‚ùå python not at extension position 5\"
                echo \"Extension at position 5: \$extension_line\"
                echo \"\"
                echo \"All extensions (non-comment lines):\"
                grep -v \"^#\" \$manifest | grep -v \"^$\" | cat -n
                exit 1
              fi
            else
              echo \"‚ùå reorder command failed\"
              exit 1
            fi
          '"

      - name: Test manifest comment preservation
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          echo "Testing that comments are preserved in manifest operations..."

          flyctl ssh console --app $app_name --user developer --command "/bin/bash -lc '
            cd /workspace/scripts/lib
            manifest=\"extensions.d/active-extensions.conf\"

            echo \"Using test fixture with comments...\"
            cp /tmp/manifest-comments.conf \$manifest

            echo \"\"
            echo \"=== Manifest with comments ===\"
            cat \$manifest

            echo \"\"
            echo \"Running: extension-manager deactivate python\"
            bash extension-manager.sh deactivate python

            echo \"\"
            echo \"=== Manifest after deactivate ===\"
            cat \$manifest

            echo \"\"
            echo \"Verifying comments preserved...\"
            if grep -q \"^# My custom header comment\" \$manifest && \
               grep -q \"^# Language runtimes\" \$manifest && \
               grep -q \"^# This is my important comment\" \$manifest; then
              echo \"‚úÖ All comments preserved\"
            else
              echo \"‚ùå Comments were not preserved\"
              exit 1
            fi

            if grep -q \"^python\" \$manifest; then
              echo \"‚ùå python still in manifest\"
              exit 1
            else
              echo \"‚úÖ python correctly removed\"
            fi
          '"

      - name: Cleanup
        if: always()
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          machines=$(flyctl machine list --app $app_name --json 2>/dev/null | jq -r '.[].id' || echo "")
          for machine in $machines; do
            [[ -z "$machine" ]] && continue
            flyctl machine stop $machine --app $app_name || true
            sleep 2
            flyctl machine destroy $machine --app $app_name --force || true
          done

          volumes=$(flyctl volumes list --app $app_name --json 2>/dev/null | jq -r '.[].id' || echo "")
          for volume in $volumes; do
            [[ -z "$volume" ]] && continue
            flyctl volumes destroy $volume --app $app_name --yes || true
          done

          flyctl apps destroy $app_name --yes || true
          rm -f test_key test_key.pub

  # ============================================================================
  # Job 8: Dependency Chain Tests
  # ============================================================================
  dependency-chain-tests:
    name: Test Dependency Chain Resolution
    runs-on: ubuntu-latest
    timeout-minutes: 50
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Install Fly CLI
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Generate test app name
        id: app-name
        run: |
          timestamp=$(date +%s)
          app_name="${TEST_APP_PREFIX}-deps-${timestamp}"
          echo "app_name=$app_name" >> $GITHUB_OUTPUT

      - name: Create test SSH key
        run: |
          ssh-keygen -t ed25519 -f test_key -N "" -C "deps-test"
          chmod 600 test_key
          chmod 644 test_key.pub

      - name: Prepare fly.toml
        env:
          APP_NAME: ${{ steps.app-name.outputs.app_name }}
          VOLUME_NAME: "test_data"
          VOLUME_SIZE: "15"
          VM_MEMORY: "4096"
          CPU_KIND: "shared"
          CPU_COUNT: "2"
          CI_MODE: "true"
        run: ./scripts/prepare-fly-config.sh --ci-mode

      - name: Deploy test environment
        run: |
          flyctl apps create ${{ steps.app-name.outputs.app_name }} --org personal || true
          flyctl deploy --app ${{ steps.app-name.outputs.app_name }} \
            --strategy immediate \
            --wait-timeout 600 \
            --ha=false

      - name: Wait for deployment
        timeout-minutes: 8
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"
          max_wait=420
          interval=15
          elapsed=0

          while [ $elapsed -lt $max_wait ]; do
            status_output=$(flyctl status --app $app_name 2>&1 || echo "error")

            if echo "$status_output" | grep -q "running"; then
              echo "‚úÖ Deployment ready"
              break
            elif echo "$status_output" | grep -q "failed\|crashed\|error"; then
              echo "‚ùå Deployment failed"
              exit 1
            fi

            sleep $interval
            elapsed=$((elapsed + interval))
          done

      - name: Copy test fixture to VM
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          echo "Copying test fixture to VM..."
          flyctl ssh sftp shell --app $app_name <<'SFTP_EOF'
            put .github/workflows/test-fixtures/manifest-only-top-level.conf /tmp/manifest-top-level.conf
            bye
          SFTP_EOF

      - name: Test transitive dependency installation
        timeout-minutes: 25
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          echo "Testing transitive dependencies: nodejs-devtools -> nodejs -> mise-config..."

          flyctl ssh console --app $app_name --user developer --command "/bin/bash -c '
            cd /workspace/scripts/lib
            manifest=\"extensions.d/active-extensions.conf\"

            echo \"Using test fixture with only top-level extension...\"
            cp /tmp/manifest-top-level.conf \$manifest

            echo \"\"
            echo \"=== Manifest (only top-level extension) ===\"
            cat \$manifest

            echo \"\"
            echo \"Running: extension-manager install-all\"
            if timeout 20m bash extension-manager.sh install-all 2>&1 | tee /tmp/install.log; then
              echo \"\"
              echo \"‚úÖ install-all completed\"

              echo \"\"
              echo \"=== Manifest after install ===\"
              cat \$manifest

              echo \"\"
              echo \"Verifying dependency chain was installed...\"
              for dep in mise-config nodejs nodejs-devtools; do
                if grep -q \"^\$dep\" \$manifest; then
                  echo \"‚úÖ \$dep in manifest\"
                else
                  echo \"‚ùå \$dep missing from manifest\"
                  exit 1
                fi
              done
            else
              echo \"‚ùå install-all failed\"
              tail -50 /tmp/install.log
              exit 1
            fi
          '"

      - name: Test missing dependency error handling
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          echo "Testing error handling when dependency is missing..."

          flyctl ssh console --app $app_name --user developer --command "/bin/bash -lc '
            cd /workspace/scripts/lib
            manifest=\"extensions.d/active-extensions.conf\"

            echo \"Creating manifest with nodejs only...\"
            echo \"nodejs\" > \$manifest

            echo \"\"
            echo \"Temporarily disabling mise to test prerequisite check...\"
            if command -v mise >/dev/null 2>&1; then
              mise_path=\$(command -v mise)
              sudo mv \$mise_path \${mise_path}.disabled 2>/dev/null || mv \$mise_path \${mise_path}.disabled
            fi

            echo \"\"
            echo \"Running: extension-manager install nodejs (should fail - mise missing)\"
            # Capture exit code before piping to tee
            bash extension-manager.sh install nodejs 2>&1 | tee /tmp/prereq_fail.log
            install_exit=\${PIPESTATUS[0]}

            if [ \$install_exit -eq 0 ]; then
              echo \"‚ùå Installation succeeded when mise dependency missing\"
              sudo mv \${mise_path}.disabled \$mise_path 2>/dev/null || mv \${mise_path}.disabled \$mise_path
              cat /tmp/prereq_fail.log
              exit 1
            else
              echo \"\"
              echo \"‚úÖ Installation correctly failed due to missing mise dependency\"

              if grep -qi \"prerequisite\|mise.*required\|mise.*not found\" /tmp/prereq_fail.log; then
                echo \"‚úÖ Appropriate error message shown (dependency check working)\"
              else
                echo \"‚ö†Ô∏è  Error message could be clearer\"
                cat /tmp/prereq_fail.log
              fi

              # Restore mise for subsequent tests
              sudo mv \${mise_path}.disabled \$mise_path 2>/dev/null || mv \${mise_path}.disabled \$mise_path
            fi
          '"

      - name: Cleanup
        if: always()
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          machines=$(flyctl machine list --app $app_name --json 2>/dev/null | jq -r '.[].id' || echo "")
          for machine in $machines; do
            [[ -z "$machine" ]] && continue
            flyctl machine stop $machine --app $app_name || true
            sleep 2
            flyctl machine destroy $machine --app $app_name --force || true
          done

          volumes=$(flyctl volumes list --app $app_name --json 2>/dev/null | jq -r '.[].id' || echo "")
          for volume in $volumes; do
            [[ -z "$volume" ]] && continue
            flyctl volumes destroy $volume --app $app_name --yes || true
          done

          flyctl apps destroy $app_name --yes || true
          rm -f test_key test_key.pub

  # ============================================================================
  # Job 9: Extension Combinations
  # ============================================================================
  extension-combinations:
    name: Test Combination - ${{ matrix.combination.name }}
    runs-on: ubuntu-latest
    timeout-minutes: 90
    permissions:
      contents: read
    # Only run on workflow_dispatch or when explicitly requested via commit message
    if: github.event_name == 'workflow_dispatch' || contains(github.event.head_commit.message, '[test-combinations]')

    strategy:
      fail-fast: false
      matrix:
        combination:
          - { name: 'core-stack', extensions: 'workspace-structure,mise-config,ssh-environment', description: 'Protected Core Extensions' }
          - { name: 'mise-stack', extensions: 'workspace-structure,mise-config,nodejs,python,rust,golang,ssh-environment', description: 'mise-Powered Languages' }
          - { name: 'full-node', extensions: 'workspace-structure,nodejs,nodejs-devtools,claude-config', description: 'Complete Node.js Development Stack' }
          - { name: 'fullstack', extensions: 'workspace-structure,nodejs,python,docker,cloud-tools', description: 'Python + Docker + Cloud' }
          - { name: 'systems', extensions: 'workspace-structure,rust,golang,docker', description: 'Rust + Go + Docker' }
          - { name: 'enterprise', extensions: 'workspace-structure,nodejs,jvm,docker,infra-tools', description: 'JVM + Docker + Infrastructure' }
          - { name: 'ai-dev', extensions: 'workspace-structure,nodejs,python,ai-tools,monitoring', description: 'Python + AI Tools + Monitoring' }

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Install Fly CLI
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Generate test app name
        id: app-name
        run: |
          timestamp=$(date +%s)
          app_name="${TEST_APP_PREFIX}-combo-${{ matrix.combination.name }}-${timestamp}"
          echo "app_name=$app_name" >> $GITHUB_OUTPUT

      - name: Create test SSH key
        run: |
          ssh-keygen -t ed25519 -f test_key -N "" -C "ext-test"
          chmod 600 test_key
          chmod 644 test_key.pub

      - name: Prepare fly.toml for testing
        env:
          APP_NAME: ${{ steps.app-name.outputs.app_name }}
          VOLUME_NAME: "test_data"
          VOLUME_SIZE: "20"
          VM_MEMORY: "16384"
          CPU_KIND: "performance"
          CPU_COUNT: "4"
          CI_MODE: "true"
        run: |
          ./scripts/prepare-fly-config.sh --ci-mode

      - name: Deploy test environment
        run: |
          flyctl apps create ${{ steps.app-name.outputs.app_name }} --org personal || true

          flyctl volumes create test_data \
            --app ${{ steps.app-name.outputs.app_name }} \
            --region ${REGION} \
            --size 20 \
            --no-encryption \
            --yes

          ssh_key_content=$(cat test_key.pub)
          flyctl secrets set AUTHORIZED_KEYS="$ssh_key_content" \
            --app ${{ steps.app-name.outputs.app_name }}
          flyctl secrets set CI_MODE="true" \
            --app ${{ steps.app-name.outputs.app_name }}

          # Deploy with retry logic
          max_attempts=3
          attempt=1
          while [ $attempt -le $max_attempts ]; do
            echo "Deployment attempt $attempt of $max_attempts..."
            if flyctl deploy --app ${{ steps.app-name.outputs.app_name }} --strategy immediate --wait-timeout 300s --yes; then
              echo "‚úÖ Deployment successful"
              break
            else
              if [ $attempt -lt $max_attempts ]; then
                wait_time=$((30 * attempt))
                echo "‚ö†Ô∏è  Deployment failed, retrying in ${wait_time}s..."
                sleep $wait_time
                attempt=$((attempt + 1))
              else
                echo "‚ùå Deployment failed after $max_attempts attempts"
                exit 1
              fi
            fi
          done

      - name: Wait for deployment
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"
          timeout=300
          elapsed=0
          interval=20

          while [ $elapsed -lt $timeout ]; do
            status_output=$(flyctl status --app $app_name 2>&1)

            if echo "$status_output" | grep -q "started"; then
              echo "‚úÖ Deployment successful"
              sleep 45
              break
            fi

            sleep $interval
            elapsed=$((elapsed + interval))
          done

      - name: Add extension combination to manifest
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"
          extensions="${{ matrix.combination.extensions }}"

          echo "Adding extensions to manifest: $extensions"

          flyctl ssh console --app $app_name --user developer --command "/bin/bash -c '
            cd /workspace/scripts/lib
            manifest_file=\"extensions.d/active-extensions.conf\"
            failed_extensions=()

            # Create manifest from CI template (already has protected extensions)
            if [ ! -f \"\$manifest_file\" ]; then
              cp extensions.d/active-extensions.ci.conf \"\$manifest_file\" 2>/dev/null || touch \"\$manifest_file\"
            fi

            # Protected extensions already in CI conf - no need to add
            protected=\"workspace-structure mise-config ssh-environment\"

            # Verify protected extensions are present
            echo \"Verifying protected extensions from CI config...\"
            for ext in workspace-structure mise-config ssh-environment; do
              if grep -q \"^\$ext\$\" \"\$manifest_file\"; then
                echo \"‚úÖ \$ext present\"
              else
                echo \"‚ùå \$ext missing from CI config\"
                exit 1
              fi
            done

            # Split extensions and add non-protected ones
            echo \"\"
            echo \"Adding combination extensions (skipping protected)...\"
            IFS=\",\" read -ra EXT_ARRAY <<< \"$extensions\"

            for ext in \"\${EXT_ARRAY[@]}\"; do
              ext=\$(echo \"\$ext\" | xargs)  # Trim whitespace

              # Skip if protected (already in CI conf)
              if echo \"\$protected\" | grep -q \"\$ext\"; then
                echo \"‚è≠Ô∏è  Skipping \$ext (protected, already in CI conf)\"
                continue
              fi

              if ! grep -q \"^\$ext\$\" \"\$manifest_file\" 2>/dev/null; then
                echo \"\$ext\" >> \"\$manifest_file\"
                echo \"‚úÖ \$ext added to manifest\"
              else
                echo \"‚úÖ \$ext already in manifest\"
              fi
            done

            echo \"\"
            echo \"=== Extensions in Manifest ===\"
            grep -v \"^[[:space:]]*#\" \"\$manifest_file\" | grep -v \"^[[:space:]]*$\" || echo \"(empty)\"
          '"

      - name: Install all extensions from manifest
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          echo "Running extension-manager install-all with extension combination..."

          flyctl ssh console --app $app_name --user developer --command "/bin/bash -c '
            if timeout 60m bash -c \"cd /workspace/scripts/lib && bash extension-manager.sh install-all\" 2>&1 | tee /tmp/configure-combo.log; then
              echo \"‚úÖ Configuration completed\"
            else
              echo \"‚ùå Configuration failed\"
              tail -100 /tmp/configure-combo.log
              exit 1
            fi
          '"

      - name: Verify no conflicts
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          echo "Checking for conflicts or errors..."

          flyctl ssh console --app $app_name --user developer --command "/bin/bash -c '
            if [ -f /tmp/configure-combo.log ]; then
              # Check for common conflict indicators
              if grep -qi \"conflict\|collision\|duplicate\" /tmp/configure-combo.log; then
                echo \"‚ö†Ô∏è  Potential conflicts detected\"
                grep -i \"conflict\|collision\|duplicate\" /tmp/configure-combo.log
              else
                echo \"‚úÖ No conflicts detected\"
              fi
            fi
          '"

      - name: Test cross-extension functionality
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"
          combo="${{ matrix.combination.name }}"

          echo "Testing cross-extension functionality for $combo..."

          flyctl ssh console --app $app_name --user developer --command "/bin/bash -lc '
            # Source SSH environment for non-interactive sessions
            if [ -f /etc/profile.d/00-ssh-environment.sh ]; then
              source /etc/profile.d/00-ssh-environment.sh
            fi

            case \"$combo\" in
              core-stack)
                echo \"Testing Core Infrastructure...\"
                # Verify workspace structure
                test -d /workspace/src && echo \"‚úÖ Workspace structure created\"
                # Verify SSH environment
                test -f /etc/profile.d/00-ssh-environment.sh && echo \"‚úÖ SSH environment configured\"
                # Verify Node.js
                node --version && npm --version && echo \"‚úÖ Node.js available\"
                ;;
              mise-stack)
                echo \"Testing mise-Powered Language Stack...\"

                # Verify mise is installed
                if ! command -v mise >/dev/null 2>&1; then
                  echo \"‚ùå mise not installed\"
                  exit 1
                fi
                echo \"‚úÖ mise: \$(mise --version)\"

                # Show all mise-managed tools
                echo \"\"
                echo \"mise-managed tools:\"
                mise ls

                # Test Node.js
                echo \"\"
                echo \"Testing Node.js (via mise)...\"
                node --version && npm --version
                mise ls node && echo \"‚úÖ Node.js managed by mise\"

                # Test Python
                echo \"\"
                echo \"Testing Python (via mise)...\"
                python3 --version
                mise ls python && echo \"‚úÖ Python managed by mise\"

                # Test Rust
                echo \"\"
                echo \"Testing Rust (via mise)...\"
                rustc --version && cargo --version
                mise ls rust && echo \"‚úÖ Rust managed by mise\"

                # Test Go
                echo \"\"
                echo \"Testing Go (via mise)...\"
                go version
                mise ls go && echo \"‚úÖ Go managed by mise\"

                echo \"\"
                echo \"‚úÖ mise-powered language stack verified\"
                ;;
              full-node)
                echo \"Testing Complete Node.js Stack...\"
                node --version && npm --version
                npx tsc --version
                npx eslint --version
                npx prettier --version
                command -v claude >/dev/null 2>&1 && echo \"‚úÖ Claude CLI available\" || echo \"‚ö†Ô∏è  Claude CLI not in PATH\"
                ;;
              fullstack)
                echo \"Testing Python + Docker + Cloud combination...\"
                python3 --version && docker --version && node --version
                ;;
              systems)
                echo \"Testing Rust + Go + Docker combination...\"
                rustc --version && go version && docker --version
                ;;
              enterprise)
                echo \"Testing JVM + Docker + Infrastructure combination...\"
                java -version && terraform version && docker --version && node --version
                ;;
              ai-dev)
                echo \"Testing Python + AI Tools + Monitoring combination...\"
                python3 --version && node --version
                ollama --version || echo \"‚ö†Ô∏è  ollama not ready\"
                command -v claude-monitor >/dev/null 2>&1 && echo \"‚úÖ Monitoring available\" || echo \"‚ö†Ô∏è  Monitoring not in PATH\"
                ;;
            esac

            echo \"‚úÖ Cross-extension functionality verified\"
          '"

      - name: Cleanup test resources
        if: always() && !inputs.skip_cleanup
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          machines=$(flyctl machine list --app $app_name --json 2>/dev/null | jq -r '.[].id' || echo "")
          for machine in $machines; do
            [[ -z "$machine" ]] && continue
            flyctl machine stop $machine --app $app_name || true
            sleep 3
            flyctl machine destroy $machine --app $app_name --force || true
          done

          volumes=$(flyctl volumes list --app $app_name --json 2>/dev/null | jq -r '.[].id' || echo "")
          for volume in $volumes; do
            [[ -z "$volume" ]] && continue
            flyctl volumes destroy $volume --app $app_name --yes || true
          done

          flyctl apps destroy $app_name --yes || true
          rm -f test_key test_key.pub

  # ============================================================================
  # Job 5: Report Test Results
  # ============================================================================
  report-results:
    name: Report Test Results
    runs-on: ubuntu-latest
    needs: [extension-manager-validation, extension-syntax-validation]
    if: always()
    permissions:
      contents: read

    steps:
      - name: Generate test report
        run: |
          echo "# Extension System Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Testing manifest-based extension system (Extension API v1.0)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Critical Jobs Status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Job | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Extension Manager Validation | ${{ needs.extension-manager-validation.result == 'success' && '‚úÖ Passed' || '‚ùå Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Extension Syntax Validation | ${{ needs.extension-syntax-validation.result == 'success' && '‚úÖ Passed' || '‚ùå Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "_Note: Individual extensions (including core extensions) are tested in the per-extension-tests matrix job._" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ needs.extension-manager-validation.result }}" = "success" ] && \
             [ "${{ needs.extension-syntax-validation.result }}" = "success" ]; then
            echo "## ‚úÖ Overall Result: PASSED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "All critical extension system validation tests passed successfully!" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Validated Features" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ Manifest-based activation system" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ Extension API v1.0 compliance" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ Extension manager commands (activate, install, status, list)" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ Script syntax and error handling" >> $GITHUB_STEP_SUMMARY
          else
            echo "## ‚ùå Overall Result: FAILED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Some validation tests failed. Please review the job logs for detailed error information." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Failed Jobs" >> $GITHUB_STEP_SUMMARY
            [ "${{ needs.extension-manager-validation.result }}" != "success" ] && echo "- ‚ùå Extension Manager Validation" >> $GITHUB_STEP_SUMMARY
            [ "${{ needs.extension-syntax-validation.result }}" != "success" ] && echo "- ‚ùå Extension Syntax Validation" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "_Workflow run: [${{ github.run_id }}](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})_" >> $GITHUB_STEP_SUMMARY
